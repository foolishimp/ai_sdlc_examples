# ADR-003: Layered Architecture with Model-First Design

**Status**: Accepted
**Date**: 2026-02-20
**Feature**: REQ-F-CDME-001
**Drives**: REQ-F-PDM-001, REQ-NFR-PERF-001, REQ-NFR-SEC-001

---

## Context

CDME must separate logical data model from physical storage (REQ-F-PDM-001), support multiple execution frameworks (REQ-NFR-PERF-001 mentions "at least one distributed framework binding"), keep business logic pure and immutable (REQ-NFR-SEC-001), and be deployable as a library/engine (ASM-005).

The project constraints specify:
- "Model layer has zero external dependencies"
- "Compiler depends on model, never the reverse"
- "Physical bindings depend on logical topology"

This demands a strict dependency direction.

## Decision

Adopt a **four-layer architecture** with strict downward-only dependencies:

1. **Model Layer** (zero external deps) -- Pure domain types, category algebra, type system, grain system, adjoint interfaces
2. **Compiler Layer** (depends on Model) -- Path validation, type unification, grain checking, context checking, artifact compilation
3. **Runtime Layer** (depends on Model + Compiler) -- Execution engine abstraction, telemetry, error routing, accounting, adjoint metadata capture
4. **Integration Layer** (depends on Runtime) -- Spark binding, OpenLineage, regulatory packaging, external calculators

Each layer is a separate sbt module with enforced compile-time dependency boundaries.

## Alternatives Considered

### Alternative 1: Hexagonal Architecture (Ports and Adapters)

**Pros**: Well-suited for swappable adapters (Spark, Flink, etc.). Clean separation of domain and infrastructure.
**Cons**: The hexagonal pattern treats all external interfaces equally, but CDME has a clear top-to-bottom flow (define -> compile -> execute -> integrate). Ports-and-adapters adds complexity for the common case where the flow is linear. The "port" abstraction is unnecessary when the Scala trait system already provides interface abstraction.

**Rejected because**: CDME's flow is predominantly linear (definition -> compilation -> execution). Hexagonal adds abstraction overhead without proportional benefit for this specific domain. The trait-based `ExecutionEngine` interface already provides the adapter pattern where needed.

### Alternative 2: Monolithic Single Module

**Pros**: Simpler build; no module boundary management; faster compilation.
**Cons**: No enforcement of dependency direction. Model code could accidentally depend on Spark. Business logic could leak into integration code. Contradicts project constraint "Model layer has zero external dependencies."

**Rejected because**: Violates project constraints. Dependency direction enforcement is a critical architectural property for a system that claims mathematical guarantees.

### Alternative 3: Microkernel / Plugin Architecture

**Pros**: Maximum extensibility; each component is a plugin.
**Cons**: Over-engineering for a library. Plugins need a registry, lifecycle management, and dependency resolution. CDME is not a platform; it is a computation engine. The plugin overhead would slow development without adding value.

**Rejected because**: CDME is a library, not a platform. Plugin architecture adds lifecycle complexity without justifying it for the expected extension points (new execution frameworks, new error sinks).

## Consequences

**Positive**:
- Dependency direction is enforced at compile time via sbt module boundaries
- Model layer can be used independently (e.g., for LDM definition and validation without execution)
- Spark dependency is confined to a single module (`cdme-spark`); replacing Spark requires only a new module
- Business logic purity is structurally enforced (model layer has no way to introduce side effects)

**Negative**:
- Multi-module sbt build is slower to compile than single module
- Cross-module refactoring requires careful coordination
- Some types that are logically related (e.g., `AdjointMorphism` in model and `AdjointCapture` in runtime) are split across modules

**Risks**:
- If the layer boundaries are drawn incorrectly, significant refactoring will be needed. Mitigated by aligning layers with the natural computation flow (define -> compile -> execute -> integrate).

---

**Implements**: REQ-F-PDM-001 (LDM/PDM separation), REQ-NFR-PERF-001 (framework-agnostic execution), REQ-NFR-SEC-001 (immutable business logic)
