# ADR-005: Adjoint-as-Trait for Morphism Design

**Status**: Accepted
**Date**: 2026-02-20
**Feature**: REQ-F-CDME-001
**Drives**: REQ-F-ADJ-001, REQ-F-ADJ-002, REQ-F-ADJ-003, REQ-F-ADJ-004, REQ-F-ADJ-005, REQ-F-ADJ-006, REQ-F-ADJ-007, REQ-F-ADJ-008, REQ-BR-ADJ-001

---

## Context

Every morphism in CDME must implement both a forward and backward function (REQ-F-ADJ-001). The backward function varies by cardinality type: exact inverse (1:1), preimage lookup (N:1), parent collection (1:N), reverse-join table (aggregation), passed + filtered (filter). Adjoint composition must be contravariant (REQ-F-ADJ-007). Backward metadata must be captured during forward execution (REQ-F-ADJ-008).

The core design question is: how should the adjoint interface be structured so that:
1. All morphisms are forced to provide backward functions
2. Cardinality-specific strategies are type-safe
3. Forward execution can capture metadata for backward traversal
4. The interface is extensible for new morphism types (e.g., future Frobenius extension)

## Decision

Define `AdjointMorphism[A, B]` as a **mandatory trait** that every morphism must extend. Use a sealed subtrait hierarchy for cardinality-specific adjoint strategies. Forward execution produces both the result and backward metadata as a paired output.

```scala
trait AdjointMorphism[A, B]:
  def id: MorphismId
  def domain: EntityId
  def codomain: EntityId
  def cardinality: CardinalityType
  def forward(input: A, ctx: ExecutionContext): Either[ErrorObject, (B, BackwardMetadata)]
  def backward(output: B, metadata: BackwardMetadata): Either[ErrorObject, BackwardResult[A]]
  def containment: ContainmentType  // Exact, Superset, Declared

trait IsomorphicAdjoint[A, B] extends AdjointMorphism[A, B]:
  override def containment: ContainmentType = ContainmentType.Exact

trait PreimageAdjoint[A, B] extends AdjointMorphism[A, B]:
  override def containment: ContainmentType = ContainmentType.Superset

// ... KleisliAdjoint, AggregationAdjoint, FilterAdjoint
```

## Alternatives Considered

### Alternative 1: Separate Forward and Backward Morphisms

```scala
trait ForwardMorphism[A, B]:
  def apply(input: A): Either[ErrorObject, B]

trait BackwardMorphism[B, A]:
  def apply(output: B): Either[ErrorObject, A]

case class AdjointPair[A, B](forward: ForwardMorphism[A, B], backward: BackwardMorphism[B, A])
```

**Pros**: Simpler individual traits. Forward and backward can be defined and tested independently.
**Cons**: No structural guarantee that forward and backward are paired. Forward metadata capture must be coordinated externally. Easy to forget to define a backward morphism. The pairing is a runtime construct, not a compile-time guarantee.

**Rejected because**: The requirement states "morphisms without a backward function shall be rejected at definition time" (REQ-F-ADJ-001). Separate traits make this an administrative check rather than a structural guarantee.

### Alternative 2: Typeclass-Based Adjoints

```scala
trait HasAdjoint[F[_, _]]:
  def forward[A, B](f: F[A, B], input: A): Either[ErrorObject, B]
  def backward[A, B](f: F[A, B], output: B): Either[ErrorObject, A]
```

**Pros**: Maximally generic. Can be added to existing morphism types retroactively.
**Cons**: Loss of cardinality-specific typing. Requires implicit resolution which can be opaque. Metadata capture pattern does not fit naturally into typeclasses. Over-abstraction for a concrete domain.

**Rejected because**: Typeclasses are appropriate for ad-hoc polymorphism over types you do not control. CDME controls all morphism types; a trait hierarchy is simpler and more direct.

### Alternative 3: Optional Backward (with Validation)

```scala
trait Morphism[A, B]:
  def forward(input: A): Either[ErrorObject, B]
  def backward: Option[B => Either[ErrorObject, A]]
```

**Pros**: Allows morphisms without backward for intermediate development. Less restrictive.
**Cons**: Directly contradicts REQ-F-ADJ-001 which requires backward on every morphism. `Option[backward]` creates runtime failures instead of compile-time guarantees. The intent specifically chose Adjoints over Daggers because of the mandatory backward property.

**Rejected because**: Violates REQ-F-ADJ-001. If backward is optional, the adjoint guarantees collapse.

## Consequences

**Positive**:
- Every morphism is forced at compile time to provide both forward and backward
- Cardinality-specific subtraits enable type-safe strategy selection
- Forward execution produces metadata alongside results (paired output)
- Contravariant composition is structurally enforced (composer checks trait types)
- Extensible: `FrobeniusAdjoint` could be added as a subtrait in the future

**Negative**:
- External calculators that cannot provide a backward function must use `OpaqueAdjoint` with manually declared containment bounds
- The paired output `(B, BackwardMetadata)` adds complexity to the forward execution signature
- Testing morphisms requires providing both directions

**Risks**:
- Backward metadata for aggregation (reverse-join tables) can be large. Mitigated by configurable storage budgets (REQ-NFR-PERF-003) and the fact that metadata size is bounded by O(n) where n is input record count.

---

**Implements**: REQ-F-ADJ-001 through REQ-F-ADJ-008, REQ-BR-ADJ-001
