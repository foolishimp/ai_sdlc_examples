# ADR-004: Either Monad for Error Handling

**Status**: Accepted
**Date**: 2026-02-20
**Feature**: REQ-F-CDME-001
**Drives**: REQ-F-ERR-001, REQ-F-ERR-002, REQ-F-ERR-003, REQ-BR-ERR-001

---

## Context

CDME requires that all morphism failures be represented via Either monad semantics (REQ-F-ERR-001), that no record is silently dropped (REQ-BR-ERR-001), and that error handling is idempotent and deterministic (REQ-F-ERR-003). The system also requires structured error objects (REQ-F-ERR-002).

There are two distinct error domains:
1. **Definition-time errors** (compilation failures): type mismatches, grain violations, missing morphisms
2. **Runtime errors** (data-level failures): refinement predicate violations, type coercion failures, external calculator failures

The error handling strategy must work correctly in a distributed execution context (Spark) where exceptions can cause task failures and retries.

## Decision

Use **`Either[ErrorObject, Value]`** as the universal error representation for both definition-time and runtime errors. Do not use exceptions for any business-level error. Do not use `cats.data.Validated` or accumulating error types for runtime errors.

```scala
// Definition-time
def compile(path: PathExpression): Either[List[ValidationError], CompiledPath]

// Runtime (per-record)
def apply(record: Record): Either[ErrorObject, Record]
```

Definition-time compilation accumulates ALL errors (returns `List[ValidationError]`).
Runtime morphism application returns a single `Either` per record.

## Alternatives Considered

### Alternative 1: Cats Validated (Accumulating Errors)

```scala
import cats.data.Validated
def apply(record: Record): Validated[NonEmptyList[ErrorObject], Record]
```

**Pros**: Accumulates multiple errors per record. Rich combinator library. Applicative composition.
**Cons**: Adds `cats-core` as a dependency to the model layer (violating zero-dependency constraint). Accumulating errors per record is unnecessary -- a record either succeeds or fails at a specific morphism. The overhead of `NonEmptyList` per record is wasteful when most records succeed.

**Rejected because**: External dependency in model layer; accumulating errors per record is not needed (a morphism application either succeeds or fails at one point).

### Alternative 2: Scala 3 Boundary/Break (Non-Local Return)

```scala
boundary:
  val result = morphism.apply(record).?
```

**Pros**: Cleaner syntax for short-circuiting. Native Scala 3.
**Cons**: `boundary/break` is syntactic sugar over exceptions. In distributed Spark execution, exceptions cause task failures and retries, which breaks the determinism requirement. Not serialisable for error objects.

**Rejected because**: Relies on exceptions under the hood, which breaks determinism in distributed execution.

### Alternative 3: Result Type with Exception Fallback

```scala
sealed trait Result[+E, +A]
case class Success[A](value: A) extends Result[Nothing, A]
case class Failure[E](error: E) extends Result[E, Nothing]
// With try/catch at Spark boundary
```

**Pros**: Custom type avoids external dependency. Can add custom methods.
**Cons**: Reinventing `Either` with different names. The Scala standard library `Either` is well-understood, well-tested, and has extensive combinator support. A custom type adds maintenance burden without benefit.

**Rejected because**: Reinventing a well-solved problem. Standard library `Either` is sufficient and universally understood.

## Consequences

**Positive**:
- Zero external dependencies for error handling
- Deterministic: `Either` is a pure value, no exception-based control flow
- Idempotent: same input always produces same `Either` result
- Serialisable: `ErrorObject` is a data class, easily serialised to JSON/Parquet
- Spark-compatible: `Either` values are regular data, not exceptions
- Definition-time accumulation: `List[ValidationError]` collects all errors before returning

**Negative**:
- Cannot accumulate multiple errors per record at runtime (only the first failure point is captured)
- Requires disciplined use of `.map` / `.flatMap` chains instead of imperative error handling
- Developers accustomed to exceptions may find the pattern verbose

**Risks**:
- If a morphism encounters multiple independent errors on the same record, only the first is captured. Mitigated by the fact that morphism composition is sequential (each step depends on the previous), so multiple independent errors on the same record are rare.

---

**Implements**: REQ-F-ERR-001 (Either semantics), REQ-F-ERR-002 (structured errors), REQ-F-ERR-003 (idempotent), REQ-BR-ERR-001 (no silent loss)
