# ADR-010: Programmatic API over Configuration Files

**Status**: Accepted
**Date**: 2026-02-20
**Feature**: REQ-F-CDME-001
**Drives**: REQ-F-API-001, REQ-F-INT-004

---

## Context

CDME needs an interface for defining and composing LDM entities, morphisms, and types (REQ-F-API-001). The API must enforce type safety at compile time via Scala's type system, support fluent composition, and return structured validation results.

The design question is whether the primary interface should be a programmatic Scala API, a declarative configuration file format (YAML, JSON, XML), or a DSL.

## Decision

Use a **programmatic Scala API** as the primary interface for LDM definition. Configuration files (HOCON) are used only for operational settings (PDM bindings, execution parameters, monitoring). The Scala API uses fluent builder patterns with `given` instances and extension methods for DSL-like ergonomics.

```scala
val category = LdmBuilder()
  .entity("Trade")
    .grain(Grain("Atomic"))
    .attribute("id", PrimitiveType(IntType))
    .attribute("amount", SemanticType(PrimitiveType(DecimalType), SemanticTag("Money")))
    .attribute("tradeDate", PrimitiveType(DateType))
  .entity("Counterparty")
    .grain(Grain("Atomic"))
    .attribute("id", PrimitiveType(IntType))
    .attribute("name", PrimitiveType(StringType))
  .morphism("tradeToCounterparty")
    .from("Trade").to("Counterparty")
    .cardinality(N_1)
    .forward(...)
    .backward(...)
  .build()  // returns Either[List[ValidationError], Category]
```

## Alternatives Considered

### Alternative 1: YAML/JSON Configuration as Primary

```yaml
entities:
  Trade:
    grain: Atomic
    attributes:
      id: Int
      amount: Money
morphisms:
  tradeToCounterparty:
    from: Trade
    to: Counterparty
    cardinality: N:1
```

**Pros**: Non-programmers can define mappings. Declarative. Tooling-friendly (syntax highlighting, linting).
**Cons**: No compile-time type safety. Forward/backward functions cannot be expressed in YAML. Complex morphisms (conditional, multi-step) require an embedded expression language. Validation errors are runtime errors. Loses Scala type system guarantees. Requires a parser and validator.

**Rejected because**: Cannot express forward/backward functions or complex morphisms declaratively. Compile-time type safety is a core requirement (REQ-F-API-001).

### Alternative 2: External DSL (Custom Language)

Define a custom mapping DSL that is parsed and compiled.

**Pros**: Tailored syntax for the domain. Clean separation between definition and implementation.
**Cons**: Requires building a parser, type checker, and compiler for the DSL. Enormous implementation effort. Tooling (IDE support, debugging) must be built from scratch. Users must learn a new language.

**Rejected because**: Unjustifiable implementation effort. Scala 3's type system and DSL capabilities make a custom language unnecessary.

### Alternative 3: Annotation-Based (Reflect/Macro)

```scala
@Entity(grain = "Atomic")
case class Trade(@Attribute id: Int, @Attribute amount: Money)
```

**Pros**: Concise. Feels like standard Scala.
**Cons**: Macros add compile-time complexity and are fragile across Scala versions. Annotations are limited in expressiveness (cannot express morphism composition). Reflection is not available in Spark executors. Runtime annotation processing violates the compile-time validation principle.

**Rejected because**: Macros are fragile and limited in expressiveness for morphism composition.

## Consequences

**Positive**:
- Full compile-time type safety (Scala compiler catches type errors in LDM definitions)
- Forward and backward functions are first-class Scala functions (fully expressive)
- IDE support (auto-complete, refactoring, type inspection) comes for free
- No custom parser, no custom language, no custom tooling
- Validation results are returned as `Either`, not thrown as exceptions

**Negative**:
- Users must know Scala to define LDMs (higher skill bar than YAML)
- LDM definitions are code, not configuration (cannot be changed without recompilation)
- Verbose for simple cases (entity definition requires more boilerplate than YAML)

**Mitigations**:
- Provide helper functions and syntactic sugar to reduce boilerplate for common patterns
- PDM bindings (less complex, more operational) can use HOCON config files
- Future extension: a YAML/JSON frontend can be built that generates the Scala API calls

---

**Implements**: REQ-F-API-001 (programmatic API), REQ-F-INT-004 (versioned lookups via API)
