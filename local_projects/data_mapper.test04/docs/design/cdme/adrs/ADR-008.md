# ADR-008: Monoid Typeclass for Aggregation

**Status**: Accepted
**Date**: 2026-02-20
**Feature**: REQ-F-CDME-001
**Drives**: REQ-F-LDM-006, REQ-F-LDM-007, REQ-F-INT-003

---

## Context

CDME requires that aggregation operations satisfy the Monoid Laws: the binary operation must be associative and an identity element must exist (REQ-F-LDM-006). Multi-level aggregation chains must each satisfy these laws independently (REQ-F-LDM-007). Non-associative operations must be rejected.

The system needs built-in monoids (sum, count, min, max, concatenation) and must support user-defined custom aggregations. The design must work with distributed execution where aggregation is applied in parallel across partitions and then merged.

## Decision

Use the **typeclass pattern** for Monoid, with compile-time evidence via Scala 3 `given` instances. Built-in monoids are provided. Custom monoids require the user to provide a `given Monoid[T]` instance with the user asserting associativity by declaration.

```scala
trait Monoid[T]:
  def empty: T
  def combine(a: T, b: T): T

object Monoid:
  given Monoid[Long] with
    def empty: Long = 0L
    def combine(a: Long, b: Long): Long = a + b

  given Monoid[Int] with
    def empty: Int = 0
    def combine(a: Int, b: Int): Int = a + b

  given minMonoid[T: Ordering]: Monoid[Option[T]] with
    def empty: Option[T] = None
    def combine(a: Option[T], b: Option[T]): Option[T] =
      (a, b) match
        case (Some(x), Some(y)) => Some(Ordering[T].min(x, y))
        case (Some(x), None) => Some(x)
        case (None, Some(y)) => Some(y)
        case _ => None

case class AggregationMorphism[A, B](
  groupBy: A => GroupKey,
  aggregate: (using Monoid[B]) => List[A] => B
)
```

## Alternatives Considered

### Alternative 1: Abstract Class Hierarchy

```scala
abstract class Aggregation[T]:
  def zero: T
  def merge(a: T, b: T): T

class SumAggregation extends Aggregation[Long]:
  def zero: Long = 0L
  def merge(a: Long, b: Long): Long = a + b
```

**Pros**: Familiar OOP pattern. Easy to understand.
**Cons**: Cannot retroactively add aggregation to existing types. Requires inheritance, which is inflexible. Cannot enforce that `merge` is associative at compile time. Does not compose well with Scala 3 idioms.

**Rejected because**: Typeclass pattern is more idiomatic in Scala 3 and allows retroactive implementation for types the user does not control.

### Alternative 2: Cats Monoid

```scala
import cats.Monoid
implicitly[Monoid[Long]].combine(a, b)
```

**Pros**: Battle-tested implementation. Rich combinator library. Property-based law testing built in.
**Cons**: Adds `cats-core` as a dependency to the model layer (violating zero-dependency constraint). Brings in a large transitive dependency tree. The full Cats algebra is much more than CDME needs.

**Rejected because**: External dependency in model layer violates project constraint.

### Alternative 3: Function Pair (No Typeclass)

```scala
case class AggConfig[T](zero: T, merge: (T, T) => T)
```

**Pros**: Simple. No typeclass machinery. Easy to understand.
**Cons**: No compile-time enforcement that the correct `AggConfig` is used for a given type. Easy to pass the wrong aggregation config. Cannot compose monoids automatically. Does not scale to multi-level aggregation.

**Rejected because**: Loses type safety and composability that the typeclass pattern provides.

## Consequences

**Positive**:
- Compile-time evidence: aggregation morphisms require a `given Monoid[B]` in scope
- Retroactive: users can define `given Monoid[CustomType]` for their own types
- Composable: `Monoid[(A, B)]` is derivable from `Monoid[A]` and `Monoid[B]`
- Distributed-friendly: associativity enables parallel fold across Spark partitions followed by merge
- No external dependencies

**Negative**:
- Associativity is asserted by the user, not proven by the compiler
- Users unfamiliar with typeclasses may find the pattern unfamiliar
- Implicit resolution errors can be cryptic

**Mitigations**:
- Provide clear documentation and examples for defining custom monoids
- Recommend (but do not require) property-based testing of custom monoids via scalacheck: `forAll((a, b, c) => combine(combine(a, b), c) == combine(a, combine(b, c)))`

---

**Implements**: REQ-F-LDM-006 (monoidal aggregation), REQ-F-LDM-007 (multi-level aggregation), REQ-F-INT-003 (multi-grain formulation)
