# ADR-006: Content-Addressed Versioning

**Status**: Accepted
**Date**: 2026-02-20
**Feature**: REQ-F-CDME-001
**Drives**: REQ-F-LDM-008, REQ-F-TRV-006, REQ-NFR-REG-001

---

## Context

CDME requires versioned schema definitions (REQ-F-LDM-008) where prior versions remain queryable. Execution must be deterministically reproducible (REQ-F-TRV-006) -- same inputs + same configuration = bitwise identical outputs. Regulatory compliance requires that all artifacts are versioned and content-addressed (REQ-NFR-REG-001).

The versioning strategy must:
1. Uniquely identify each schema and artifact version
2. Be deterministic (same content always produces same version ID)
3. Support change detection (different content always produces different version ID)
4. Be independent of wall-clock time or sequence numbers

## Decision

Use **content-addressed versioning** based on SHA-256 hashing of the canonical serialised form of each artifact. Every `Category`, `ExecutionArtifact`, and `RegulatoryPackage` carries its own content hash as its version identifier.

```scala
case class ContentHash(sha256: String)

def contentHash(artifact: Serialisable): ContentHash =
  ContentHash(sha256(canonicalSerialise(artifact)))

// Canonical serialisation: deterministic JSON with sorted keys, no whitespace variation
```

## Alternatives Considered

### Alternative 1: Monotonically Increasing Sequence Numbers

```scala
case class Version(seq: Long) // 1, 2, 3, ...
```

**Pros**: Simple. Human-readable. Easy to order.
**Cons**: Requires a centralised counter (single point of failure, coordination overhead). Not deterministic from content (same content can get different sequence numbers if recreated). Does not detect duplicate content. Not suitable for offline/distributed LDM definition.

**Rejected because**: Centralised counter contradicts the library deployment model (ASM-005). Not content-deterministic.

### Alternative 2: Timestamp-Based Versioning

```scala
case class Version(timestamp: Instant) // 2026-02-20T10:30:00Z
```

**Pros**: Simple. No coordination needed. Naturally ordered.
**Cons**: Clock skew can produce ordering anomalies. Same content at different times gets different versions (breaks determinism). Millisecond granularity may not be sufficient for rapid updates.

**Rejected because**: Violates determinism requirement (REQ-F-TRV-006). Same content should always produce same version.

### Alternative 3: Semantic Versioning (SemVer)

```scala
case class Version(major: Int, minor: Int, patch: Int) // 1.2.3
```

**Pros**: Human-meaningful. Communicates compatibility.
**Cons**: Requires human judgment to assign version bumps. Not content-deterministic. Two different contents could be assigned the same version by mistake. Does not support automated change detection.

**Rejected because**: Not content-deterministic; requires human assignment which is error-prone for a system that auto-generates artifacts.

## Consequences

**Positive**:
- Deterministic: same content always produces same hash
- Change detection: any content change produces a different hash
- No coordination required: hashing is local, stateless
- Audit-friendly: content integrity is verifiable by recomputing hash
- Works in distributed/offline scenarios

**Negative**:
- Not human-readable (SHA-256 hashes are opaque strings)
- No natural ordering (hashes are not sortable by time or sequence)
- Canonical serialisation must be carefully defined and stable (any serialisation format change invalidates all existing hashes)

**Mitigations**:
- Pair content hashes with creation timestamps for human display
- Maintain a version log that records (hash, timestamp, description) for navigability
- Document and test the canonical serialisation format as a contract

---

**Implements**: REQ-F-LDM-008 (schema versioning), REQ-F-TRV-006 (deterministic reproducibility), REQ-NFR-REG-001 (content-addressed audit artifacts)
