# CDME — Technical Design Specification

<!-- Implements: REQ-F-LDM-001..006, REQ-F-PDM-001..005, REQ-F-TRV-001..006, REQ-F-SHF-001, REQ-F-INT-001..008, REQ-F-TYP-001..007, REQ-F-ERR-001, REQ-F-AI-001..003, REQ-F-ACC-001..005 -->

**Version**: 1.0.0
**Date**: 2026-02-20
**Status**: Draft — Generated by v2.1 iterate(requirements→design)
**Variant**: `cdme` (Reference Architecture — Scala/Spark)
**Methodology**: AI SDLC Asset Graph Model v2.1

---

## 1. Executive Summary

CDME is a compile-time validated data transformation framework built on Category Theory. This design specifies the component architecture for a Scala 3 / Apache Spark implementation.

**Core insight**: Schemas are categories (objects + morphisms). Transformations are functors. Validation happens at definition time, not runtime. Every output traces to its source via adjoint metadata.

---

## 2. Architecture Decision Records

| ADR | Decision | Requirements |
|-----|----------|--------------|
| [ADR-001](adrs/ADR-001-adjoint-over-dagger.md) | Adjoint (Galois Connection) over Dagger Category | REQ-F-ACC-001..005 |
| [ADR-002](adrs/ADR-002-schema-registry.md) | Schema Registry as Source of Truth for LDM | REQ-F-LDM-001..003, REQ-F-PDM-001 |
| [ADR-003](adrs/ADR-003-either-monad-errors.md) | Either Monad for Error Handling | REQ-F-TYP-003, REQ-F-ERR-001 |
| [ADR-004](adrs/ADR-004-lineage-modes.md) | Three Lineage Modes (Full/Key-Derivable/Sampled) | REQ-F-INT-003, REQ-F-ACC-003 |
| [ADR-005](adrs/ADR-005-grain-hierarchy.md) | Grain Hierarchy as First-Class Concept | REQ-F-LDM-006, REQ-F-TRV-002 |
| [ADR-006](adrs/ADR-006-deterministic-execution.md) | Deterministic Execution Contract | REQ-F-TRV-005, REQ-F-INT-006 |
| [ADR-007](adrs/ADR-007-compile-vs-runtime.md) | Compile-Time vs Runtime Validation Split | REQ-F-AI-001, REQ-F-TYP-006 |
| [ADR-008](adrs/ADR-008-execution-engine.md) | Apache Spark as Execution Engine | REQ-NFR-PERF-001 |
| [ADR-009](adrs/ADR-009-scala3.md) | Scala 3 as Implementation Language | REQ-F-TYP-001..006 |
| [ADR-010](adrs/ADR-010-openlineage.md) | OpenLineage as Lineage Standard | REQ-NFR-OBS-001, REQ-F-INT-003 |

---

## 3. Component Architecture

### 3.1. TopologicalCompiler (Control Plane)

**Implements**: REQ-F-LDM-001, REQ-F-LDM-002, REQ-F-LDM-003, REQ-F-TYP-006, REQ-F-TRV-002, REQ-F-AI-001, REQ-F-AI-003

**Responsibilities**:
- Parse and validate LDM topology definitions (YAML/JSON)
- Verify path composition: morphism existence, type unification, grain safety
- Reject invalid paths at definition time
- Validate AI-generated mappings against the same rules
- Support dry-run mode for validation-only execution

**Interfaces**:
- `compile(topology: Topology, mapping: MappingDef): Either[CompilationError, ExecutionPlan]`
- `validate(path: DotPath): Either[ValidationError, ValidatedPath]`
- `dryRun(plan: ExecutionPlan): ValidationReport`

**Dependencies**:
- TypeSystem (for type unification)
- GrainChecker (for grain safety)
- AccessController (for RBAC)

### 3.2. TypeSystem

**Implements**: REQ-F-TYP-001, REQ-F-TYP-002, REQ-F-TYP-005, REQ-F-TYP-006, REQ-F-TYP-007

**Responsibilities**:
- Define primitive, sum, product, and refinement types
- Perform type unification (exact match or subtype)
- Reject implicit casts
- Enforce semantic type distinctions (Money, Date, Percent)

**Interfaces**:
- `unify(a: Type, b: Type): Either[TypeError, UnifiedType]`
- `isSubtypeOf(sub: Type, sup: Type): Boolean`
- `refine(base: Type, predicate: Predicate): RefinementType`

**Dependencies**: None (leaf component)

### 3.3. GrainChecker

**Implements**: REQ-F-LDM-006, REQ-F-TRV-002, REQ-F-INT-002, REQ-F-INT-005

**Responsibilities**:
- Validate grain compatibility on morphism composition
- Check multi-grain formulas for required aggregation wrappers
- Enforce grain hierarchy (Atomic → Daily → Monthly → Yearly)

**Interfaces**:
- `checkGrainSafety(path: ValidatedPath): Either[GrainError, GrainSafePath]`
- `validateAggregation(from: Grain, to: Grain, morphism: Fold): Either[GrainError, Unit]`

**Dependencies**: TypeSystem

### 3.4. AccessController

**Implements**: REQ-F-LDM-005

**Responsibilities**:
- Enforce morphism-level RBAC
- Filter topology view per principal (denied morphisms invisible)

**Interfaces**:
- `filterTopology(topology: Topology, principal: Principal): Topology`
- `checkAccess(morphism: Morphism, principal: Principal): Boolean`

**Dependencies**: None (leaf component)

### 3.5. SheafContextManager

**Implements**: REQ-F-SHF-001, REQ-F-TRV-003, REQ-F-PDM-002, REQ-F-PDM-003

**Responsibilities**:
- Manage contextual fibers (epoch, partition scope)
- Enforce join compatibility (same epoch or explicit temporal semantics)
- Apply boundary definitions (event windowing, snapshot versioning)

**Interfaces**:
- `validateJoinContext(left: Fiber, right: Fiber): Either[ContextError, JoinPlan]`
- `resolveBoundary(source: PhysicalSource, epoch: Epoch): DataSlice`

**Dependencies**: TopologicalCompiler (for boundary declarations)

### 3.6. MorphismExecutor (Data Plane)

**Implements**: REQ-F-TRV-001, REQ-F-INT-001, REQ-F-INT-004, REQ-F-LDM-004, REQ-F-INT-008, REQ-NFR-PERF-001

**Responsibilities**:
- Execute morphisms on distributed data (Spark DataFrames)
- Kleisli lifting (1:N scalar-to-list context switch)
- Monoidal folding (aggregation with identity element)
- Execute external computational morphisms
- Residue collection for lineage

**Sub-components**:
- **KleisliLifter**: Wraps scalar functions for 1:N traversals
- **MonoidFolder**: Applies associative reduction with identity
- **ExternalMorphismAdapter**: Bridges black-box calculators

**Interfaces**:
- `execute(plan: ExecutionPlan, data: DataFrame): Either[ExecutionError, DataFrame]`
- `lift(f: ScalarFunc, context: ListContext): ListFunc`
- `fold(monoid: Monoid[A], data: List[A]): A`

**Dependencies**:
- TypeSystem (for runtime type validation)
- AdjointMetadataCapture (for lineage)
- TelemetryWriter (for Writer monad)
- ErrorRouter (for Either bifurcation)

### 3.7. ErrorRouter (Error Domain)

**Implements**: REQ-F-TYP-003, REQ-F-TYP-004, REQ-F-ERR-001, REQ-DATA-BATCH-001, REQ-DATA-BATCH-002

**Responsibilities**:
- Bifurcate streams into Valid (Right) and Error (Left)
- Route errors to Error Sink with full context (constraint type, offending values, source entity, epoch, morphism path)
- Implement batch failure threshold
- Probabilistic circuit breaker for structural errors

**Interfaces**:
- `route(result: Either[Error, Value]): (DataFrame, DataFrame)` // (valid, error)
- `checkThreshold(errorCount: Long, totalCount: Long, config: ThresholdConfig): Boolean`
- `circuitBreak(earlyErrors: Long, sampleSize: Long, config: CircuitBreakerConfig): Boolean`

**Dependencies**: None (leaf component)

### 3.8. ImplementationFunctor (PDM Binding)

**Implements**: REQ-F-PDM-001, REQ-F-PDM-004, REQ-F-PDM-005

**Responsibilities**:
- Map logical entities to physical storage (S3, HDFS, JDBC, etc.)
- Resolve temporal bindings (epoch → physical table)
- Bind lookups (data-backed or logic-backed)

**Interfaces**:
- `bind(entity: LogicalEntity, config: PDMConfig): PhysicalBinding`
- `resolveLookup(lookup: LookupRef, epoch: Epoch): DataFrame`
- `resolveTemporalBinding(entity: LogicalEntity, epoch: Epoch): PhysicalSource`

**Dependencies**: SheafContextManager (for epoch resolution)

### 3.9. AdjointMetadataCapture

**Implements**: REQ-F-ACC-001, REQ-F-ACC-002, REQ-F-ACC-003, REQ-F-ACC-004, REQ-F-ACC-005, REQ-F-INT-003

**Responsibilities**:
- Capture source keys during forward execution
- Produce ReverseJoinMetadata (aggregations), FilteredKeysMetadata (filters), error source_keys
- Generate accounting ledger (ledger.json)
- Run completion gate verification
- Enable backward traversal without recomputation

**Interfaces**:
- `captureAggregation(inputKeys: Set[Key], outputKey: Key): ReverseJoinMetadata`
- `captureFilter(excludedKeys: Set[Key], filterCondition: String): FilteredKeysMetadata`
- `generateLedger(run: RunContext): Ledger`
- `verifyAccountingInvariant(ledger: Ledger): Either[AccountingError, VerifiedLedger]`
- `backwardTraverse(outputKey: Key): Set[SourceKey]`

**Dependencies**: MorphismExecutor (receives execution events)

### 3.10. TelemetryWriter (Writer Monad)

**Implements**: REQ-F-TRV-004, REQ-NFR-OBS-001

**Responsibilities**:
- Accumulate row counts, quality metrics, latency per morphism
- Emit OpenLineage events (START, COMPLETE, FAIL)
- Side-channel: does not affect transformation logic

**Interfaces**:
- `accumulate(morphism: Morphism, metrics: MorphismMetrics): Unit`
- `emitLineageEvent(event: OpenLineageEvent): Unit`
- `getReport(): TelemetryReport`

**Dependencies**: None (leaf component, receives callbacks)

### 3.11. LookupManager

**Implements**: REQ-F-INT-006, REQ-F-PDM-004, REQ-NFR-SEC-001

**Responsibilities**:
- Enforce versioned lookup semantics
- Reject unversioned lookups
- Guarantee same lookup+key yields same value within execution context
- Ensure lookup immutability during execution

**Interfaces**:
- `resolve(ref: LookupRef, key: LookupKey, epoch: Epoch): Either[LookupError, Value]`
- `validateVersioning(ref: LookupRef): Either[VersionError, VersionedRef]`

**Dependencies**: ImplementationFunctor (for physical resolution)

### 3.12. CostEstimator

**Implements**: REQ-F-TRV-006, REQ-NFR-PERF-002

**Responsibilities**:
- Estimate cardinality explosion before execution
- Detect data skew via sampling
- Reject plans exceeding budget
- Suggest skew mitigation (salted joins)

**Interfaces**:
- `estimate(plan: ExecutionPlan): CostEstimate`
- `checkBudget(estimate: CostEstimate, budget: Budget): Either[BudgetExceeded, Unit]`
- `detectSkew(data: DataFrame, key: String): SkewReport`

**Dependencies**: MorphismExecutor (for sampling)

---

## 4. Data Models

### 4.1. LDM Entity Definition

```yaml
# Implements: REQ-F-LDM-001, REQ-F-LDM-006
entity:
  name: String               # Unique entity name
  grain: Grain               # ATOMIC | AGGREGATE(level)
  attributes:
    - name: String
      type: ExtendedType     # Primitive | Sum | Product | Refinement
      primary_key: Boolean
      semantic_type: String?  # Money, Date, Percent (optional)
  identity_morphism: true    # Every entity has id: E -> E
```

### 4.2. Morphism Definition

```yaml
# Implements: REQ-F-LDM-002, REQ-F-LDM-003
morphism:
  name: String
  domain: EntityRef          # Source entity
  codomain: EntityRef        # Target entity
  cardinality: Cardinality   # ONE_TO_ONE | N_TO_ONE | ONE_TO_N
  type: MorphismType         # STRUCTURAL | COMPUTATIONAL | ALGEBRAIC
  access_control:            # REQ-F-LDM-005
    roles: [String]
  adjoint:                   # REQ-F-ACC-003
    strategy: AdjointStrategy  # EXACT_INVERSE | PREIMAGE | REVERSE_JOIN | FILTER_LOG
```

### 4.3. Execution Plan

```yaml
# Implements: REQ-F-TRV-006, REQ-F-AI-003
execution_plan:
  topology_version: String
  mapping_version: String
  stages:
    - morphism: MorphismRef
      input: DatasetRef
      output: DatasetRef
      estimated_cardinality: Long
      lineage_mode: FULL | KEY_DERIVABLE | SAMPLED
  budget:
    max_output_rows: Long
    max_join_depth: Int
    max_intermediate_size: Long
  dry_run: Boolean
```

### 4.4. Accounting Ledger

```json
{
  "run_id": "string",
  "input_count": 0,
  "source_key_field": "string",
  "partitions": {
    "processed": { "count": 0, "metadata_location": "string" },
    "filtered": { "count": 0, "metadata_location": "string" },
    "errored": { "count": 0, "metadata_location": "string" }
  },
  "verification": {
    "status": "balanced | unbalanced",
    "discrepancy": null
  }
}
```

---

## 5. Component Dependency Graph

```
TopologicalCompiler
├── TypeSystem
├── GrainChecker ── TypeSystem
├── AccessController
└── SheafContextManager

MorphismExecutor
├── TypeSystem
├── AdjointMetadataCapture
├── TelemetryWriter
├── ErrorRouter
└── CostEstimator

ImplementationFunctor
├── SheafContextManager
└── LookupManager
```

No circular dependencies. LDM components (TypeSystem, GrainChecker, AccessController) have zero physical storage dependencies per REQ-F-PDM-001.

---

## 6. Traceability Matrix

| Component | Implements |
|-----------|-----------|
| TopologicalCompiler | REQ-F-LDM-001, REQ-F-LDM-002, REQ-F-LDM-003, REQ-F-TYP-006, REQ-F-TRV-002, REQ-F-AI-001, REQ-F-AI-003 |
| TypeSystem | REQ-F-TYP-001, REQ-F-TYP-002, REQ-F-TYP-005, REQ-F-TYP-006, REQ-F-TYP-007 |
| GrainChecker | REQ-F-LDM-006, REQ-F-TRV-002, REQ-F-INT-002, REQ-F-INT-005 |
| AccessController | REQ-F-LDM-005 |
| SheafContextManager | REQ-F-SHF-001, REQ-F-TRV-003, REQ-F-PDM-002, REQ-F-PDM-003 |
| MorphismExecutor | REQ-F-TRV-001, REQ-F-INT-001, REQ-F-INT-004, REQ-F-LDM-004, REQ-F-INT-008, REQ-NFR-PERF-001 |
| ErrorRouter | REQ-F-TYP-003, REQ-F-TYP-004, REQ-F-ERR-001, REQ-DATA-BATCH-001, REQ-DATA-BATCH-002 |
| ImplementationFunctor | REQ-F-PDM-001, REQ-F-PDM-004, REQ-F-PDM-005 |
| AdjointMetadataCapture | REQ-F-ACC-001..005, REQ-F-INT-003 |
| TelemetryWriter | REQ-F-TRV-004, REQ-NFR-OBS-001 |
| LookupManager | REQ-F-INT-006, REQ-F-PDM-004, REQ-NFR-SEC-001 |
| CostEstimator | REQ-F-TRV-006, REQ-NFR-PERF-002 |

### Orphan Check

All 43 REQ keys map to at least one component. All 12 components implement at least one REQ key.

### Coverage gaps (NFR):
- REQ-NFR-REG-001 (Regulatory Compliance Package) — cross-cutting, implemented by AdjointMetadataCapture + TelemetryWriter + TopologicalCompiler jointly
- REQ-F-INT-007 (Identity Synthesis) — implemented within MorphismExecutor as a standard computational morphism
- REQ-F-TRV-005 (Deterministic Reproducibility) — cross-cutting, enforced by LookupManager (versioning) + MorphismExecutor (purity) + SheafContextManager (epoch pinning)
- REQ-F-AI-002 (Triangulation of Assurance) — cross-cutting, implemented by TopologicalCompiler (intent→logic) + TelemetryWriter (logic→proof) + AdjointMetadataCapture (proof→intent)

---

## 7. Technology Choices

| Decision | Choice | Rationale | ADR |
|----------|--------|-----------|-----|
| Language | Scala 3 | Strong type system, FP-first, Spark native | ADR-009 |
| Execution Engine | Apache Spark 3.5+ | Distributed compute, DataFrame API | ADR-008 |
| Lineage Standard | OpenLineage | Industry standard, Marquez integration | ADR-010 |
| Config Format | YAML + JSON Schema | Human-readable, validatable | — |
| Build Tool | sbt | Scala ecosystem standard | — |
| Error Model | Either[E, A] | Scala native, composable, no exceptions | ADR-003 |

---

## 8. Package Structure

```
src/main/scala/cdme/
├── compiler/
│   ├── TopologicalCompiler.scala
│   ├── TypeSystem.scala
│   ├── GrainChecker.scala
│   └── AccessController.scala
├── context/
│   ├── SheafContextManager.scala
│   └── LookupManager.scala
├── executor/
│   ├── MorphismExecutor.scala
│   ├── KleisliLifter.scala
│   ├── MonoidFolder.scala
│   └── ExternalMorphismAdapter.scala
├── errors/
│   └── ErrorRouter.scala
├── binding/
│   └── ImplementationFunctor.scala
├── lineage/
│   ├── AdjointMetadataCapture.scala
│   ├── AccountingLedger.scala
│   └── TelemetryWriter.scala
├── cost/
│   └── CostEstimator.scala
├── model/
│   ├── Entity.scala
│   ├── Morphism.scala
│   ├── Grain.scala
│   ├── ExtendedType.scala
│   ├── ExecutionPlan.scala
│   └── Topology.scala
└── config/
    ├── LdmConfig.scala
    ├── PdmConfig.scala
    └── JobConfig.scala
```
