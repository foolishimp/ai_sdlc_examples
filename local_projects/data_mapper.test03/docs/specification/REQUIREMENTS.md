# CDME — Requirements Specification

**Version**: 1.0.0
**Date**: 2026-02-20
**Status**: Draft — Generated by v2.1 iterate(intent→requirements)
**Methodology**: AI SDLC Asset Graph Model v2.1

---

## 1. Logical Data Model (LDM)

### REQ-F-LDM-001: Schema as Directed Graph

**Priority**: Critical
**Type**: Functional

**Description**: The LDM must be defined as a directed multigraph where entities are nodes and relationships are edges.

**Acceptance Criteria**:
- Entities are modeled as typed nodes with identity morphisms
- Relationships are modeled as directed edges with cardinality metadata
- The graph must support multiple edges between the same pair of entities

**Traces To**: INT-001, INT-002 (Axiom 1)

---

### REQ-F-LDM-002: Cardinality Types

**Priority**: Critical
**Type**: Functional

**Description**: Every edge in the LDM must define its categorical type: `1:1` (Isomorphism), `N:1` (Standard Function), or `1:N` (Kleisli Arrow).

**Acceptance Criteria**:
- Each morphism declares exactly one of: 1:1, N:1, 1:N
- Cardinality type is enforced during composition validation
- Invalid cardinality declarations are rejected at definition time

**Traces To**: INT-001, INT-002 (Axiom 1)

---

### REQ-F-LDM-003: Composition Validity via Dot Notation

**Priority**: Critical
**Type**: Functional

**Description**: A path expressed as `Entity.Relationship.Attribute` must be validated: each morphism exists in the LDM, codomain equals domain of next, grains are safe, and access permissions are satisfied.

**Acceptance Criteria**:
- Paths are validated at definition/compile time
- Invalid paths are rejected with specific error (missing morphism, type mismatch, grain violation, access denied)
- Validation covers all four conditions: existence, type match, grain safety, access control

**Traces To**: INT-001, INT-002 (Axiom 3)

---

### REQ-F-LDM-004: Monoidal Aggregation

**Priority**: Critical
**Type**: Functional

**Description**: Aggregation operations must satisfy the Monoid Laws (associativity of binary operation, existence of identity element). Non-associative aggregates must be rejected.

**Acceptance Criteria**:
- Aggregation functions declare associative operation and identity element
- Non-associative operations are rejected or flagged as non-scalable
- Aggregation over empty input yields the identity element

**Traces To**: INT-001, INT-002 (Axiom 5)

---

### REQ-F-LDM-005: Topological Access Control

**Priority**: High
**Type**: Functional

**Description**: The LDM must support RBAC on morphisms. If a principal lacks permission for a morphism, that morphism does not exist in their view of the topology.

**Acceptance Criteria**:
- Morphism-level RBAC is enforced
- Denied morphisms are invisible for path construction
- Access control is checked at validation time, not just runtime

**Traces To**: INT-001

---

### REQ-F-LDM-006: Grain and Type Metadata

**Priority**: Critical
**Type**: Functional

**Description**: Every entity must be tagged with its grain (Atomic, Aggregate) and its attributes must be typed using the extended type system.

**Acceptance Criteria**:
- Each entity has explicit grain metadata
- Each attribute has an extended type declaration
- Missing grain or type metadata is a validation error

**Traces To**: INT-001, INT-002 (Axioms 5, 7)

---

## 2. Physical Data Model (PDM)

### REQ-F-PDM-001: Functorial Mapping (LDM to PDM)

**Priority**: Critical
**Type**: Functional

**Description**: Physical storage must be abstracted. Re-pointing a logical entity from one storage medium to another must not require changing business logic or LDM definitions.

**Acceptance Criteria**:
- LDM definitions are independent of physical storage
- PDM binding change requires only PDM config update
- Business logic morphisms reference LDM entities, never physical tables

**Traces To**: INT-001, INT-002 (Axiom 2)

---

### REQ-F-PDM-002: Generation Grain Semantics

**Priority**: High
**Type**: Functional

**Description**: The PDM must declare the generation grain of each physical source: Event (continuous stream sliced by temporal windows) or Snapshot (state at a point in time).

**Acceptance Criteria**:
- Valid generation grains are [Event, Snapshot]
- Each physical source declares exactly one generation grain
- Generation grain semantics determine how boundaries are applied

**Traces To**: INT-001, INT-002 (Axiom 4)

---

### REQ-F-PDM-003: Boundary Definition

**Priority**: High
**Type**: Functional

**Description**: The PDM must define how continuous data flow is sliced into processing epochs, consistent with the generation grain semantics.

**Acceptance Criteria**:
- Boundary definitions are consistent with generation grain type
- Event boundaries use temporal windows
- Snapshot boundaries use version or timestamp

**Traces To**: INT-001, INT-002 (Axiom 4)

---

### REQ-F-PDM-004: Lookup Binding

**Priority**: Medium
**Type**: Functional

**Description**: The PDM must support binding reference data (lookups) as either data-backed (physical table) or logic-backed (computed/static).

**Acceptance Criteria**:
- Lookups declare their backing type
- Both data-backed and logic-backed lookups are supported
- Lookup binding is transparent to LDM morphisms

**Traces To**: INT-001, INT-002 (Axiom 6)

---

### REQ-F-PDM-005: Temporal Binding

**Priority**: Medium
**Type**: Functional

**Description**: The PDM must support temporal binding, allowing a single logical entity to map to different physical tables as a function of the data epoch.

**Acceptance Criteria**:
- Temporal binding is deterministic for a given epoch
- Multiple physical sources can serve the same logical entity across time
- Epoch resolution is validated at compile time

**Traces To**: INT-001

---

## 3. Traversal Engine

### REQ-F-TRV-001: Context Lifting (Kleisli)

**Priority**: Critical
**Type**: Functional

**Description**: When traversing a 1:N edge, the engine must lift execution context from Scalar to List, implementing proper flattening or explosion operations.

**Acceptance Criteria**:
- 1:N traversal produces List context automatically
- Scalar functions are lifted into list-processing functions
- Nested 1:N traversals flatten correctly

**Traces To**: INT-001, INT-002 (Axiom 3)

---

### REQ-F-TRV-002: Grain Safety

**Priority**: Critical
**Type**: Functional

**Description**: The engine must block operations that combine attributes from incompatible grains without explicit aggregation.

**Acceptance Criteria**:
- Projecting attributes from incompatible grains is rejected
- Expressions mixing incompatible grains are rejected
- Joins at different grains without aggregation are rejected
- All grain violations are caught at definition/compile time

**Traces To**: INT-001, INT-002 (Axiom 5)

---

### REQ-F-TRV-003: Boundary Alignment and Temporal Semantics

**Priority**: High
**Type**: Functional

**Description**: The engine must detect cross-boundary traversals and require declared temporal semantics (As-Of, Latest, Exact).

**Acceptance Criteria**:
- Cross-boundary traversals are detected automatically
- Temporal semantics must be declared for cross-boundary joins
- Undeclared cross-boundary traversals are rejected

**Traces To**: INT-001, INT-002 (Axiom 4)

---

### REQ-F-TRV-004: Operational Telemetry (Writer Monad)

**Priority**: High
**Type**: Functional

**Description**: The execution context must implement a Writer effect to capture row counts, quality metrics, and latency stats at every node traversal.

**Acceptance Criteria**:
- Row counts are captured at each morphism application
- Quality metrics are accumulated during traversal
- Latency is measured per-morphism
- Telemetry does not affect transformation logic (side-channel)

**Traces To**: INT-001, INT-002 (Axiom 10)

---

### REQ-F-TRV-005: Deterministic Reproducibility

**Priority**: Critical
**Type**: Functional

**Description**: The system must guarantee that any target value is deterministically derivable from the source inputs, given immutable and versioned transformations and lookups.

**Acceptance Criteria**:
- Same inputs + same config = same outputs (bitwise identical)
- All randomness is seeded and configurable
- Lookup versions are pinned per execution context

**Traces To**: INT-001, INT-002 (Axiom 6)

---

### REQ-F-TRV-006: Computational Cost Governance

**Priority**: High
**Type**: Functional

**Description**: The engine must estimate cardinality explosion before execution and block plans exceeding a declared budget.

**Acceptance Criteria**:
- Cost estimation runs before execution
- Budget is declared in execution artifact (max output rows, max join depth, max intermediate size)
- Plans exceeding budget are rejected with cardinality report

**Traces To**: INT-001

---

### REQ-F-SHF-001: Context Consistency (Sheaf-like)

**Priority**: Critical
**Type**: Functional

**Description**: Joins must respect contextual fibers: same epoch or explicit temporal semantics, compatible partitioning scopes.

**Acceptance Criteria**:
- Joins validate epoch compatibility
- Incompatible fiber joins are rejected at validation time
- Explicit temporal semantics override default epoch matching

**Traces To**: INT-001, INT-002 (Axiom 4)

---

## 4. Integration and Synthesis

### REQ-F-INT-001: Isomorphic Synthesis

**Priority**: High
**Type**: Functional

**Description**: Users must be able to define new attributes via pure functions over existing entities and attributes.

**Acceptance Criteria**:
- Pure functions can derive new attributes
- Derived attributes participate in the type system
- Synthesis morphisms compose with other morphisms

**Traces To**: INT-001, INT-002 (Axiom 9)

---

### REQ-F-INT-002: Subsequent Aggregation

**Priority**: High
**Type**: Functional

**Description**: The system must support multi-level aggregation (e.g., Atomic to Daily to Monthly) if each level satisfies the Monoid Laws and the grain hierarchy permits it.

**Acceptance Criteria**:
- Multi-level aggregation is supported
- Each level validates Monoid Laws
- Grain hierarchy is checked for compositional validity

**Traces To**: INT-001, INT-002 (Axiom 5)

---

### REQ-F-INT-003: Full Lineage Traceability

**Priority**: Critical
**Type**: Functional

**Description**: Every target value must map back to the specific source epoch, entity, and morphism path that generated it.

**Acceptance Criteria**:
- Lineage captures source entity, epoch, and morphism path
- Lineage is queryable per-record
- Lineage survives aggregation (via adjoint metadata)

**Traces To**: INT-001, INT-005

---

### REQ-F-INT-004: Complex Business Logic

**Priority**: High
**Type**: Functional

**Description**: Synthesis maps must support conditional expressions, prioritised fallback logic, multi-morphism composition, and product/tuple type construction.

**Acceptance Criteria**:
- Conditional (if-then-else) expressions are supported
- Fallback chains (coalesce) are supported
- Multiple morphisms compose into a single synthesis
- Product types can be constructed from multiple inputs

**Traces To**: INT-001, INT-002 (Axiom 9)

---

### REQ-F-INT-005: Multi-Grain Formulation

**Priority**: High
**Type**: Functional

**Description**: Formulas may reference attributes at different grains, provided finer-grained attributes are wrapped in explicit aggregation morphisms.

**Acceptance Criteria**:
- Multi-grain formulas require explicit aggregation for finer-grained attributes
- Aggregation scope aligns to the coarser entity's grain
- Direct reference to finer-grained attributes without aggregation is rejected

**Traces To**: INT-001, INT-002 (Axiom 5)

---

### REQ-F-INT-006: Versioned Lookups

**Priority**: Critical
**Type**: Functional

**Description**: All reference data usage must specify version semantics (explicit version, temporal constraint, or deterministic alias). Unversioned lookups must be rejected.

**Acceptance Criteria**:
- Every lookup declares version semantics
- Unversioned lookups are rejected at validation time
- Within a single execution context, same lookup + key yields same value

**Traces To**: INT-001, INT-002 (Axiom 6)

---

### REQ-F-INT-007: Identity Synthesis (Surrogate Keys)

**Priority**: Medium
**Type**: Functional

**Description**: The system must support deterministic key generation where the same inputs always produce the same key.

**Acceptance Criteria**:
- Key generation is deterministic (hash-based)
- Same inputs produce bitwise identical keys
- Key generation function is declared as a morphism

**Traces To**: INT-001

---

### REQ-F-INT-008: External Computational Morphisms

**Priority**: High
**Type**: Functional

**Description**: The system must support registration of black-box calculators (e.g., compiled Cashflow Engines) as standard morphisms with declared domain/codomain types, determinism assertion, and stable identifier.

**Acceptance Criteria**:
- External calculators register with typed domain and codomain
- Determinism is asserted by contract (not verified at runtime)
- Type compatibility is checked at compile time
- Calculator version is captured in lineage

**Traces To**: INT-001, INT-003, INT-002 (Axiom 9)

---

## 5. Type System

### REQ-F-TYP-001: Extended Type System

**Priority**: Critical
**Type**: Functional

**Description**: The LDM must support primitives, sum types (tagged unions), and product types (tuples/records).

**Acceptance Criteria**:
- Primitive types: String, Int, Long, Decimal, Date, Timestamp, Boolean
- Sum types: `A | B` (tagged union)
- Product types: `(A, B, C)` (tuple/record)
- Nested composition of all type constructors

**Traces To**: INT-001, INT-002 (Axiom 7)

---

### REQ-F-TYP-002: Refinement Types

**Priority**: High
**Type**: Functional

**Description**: The system must support refinement types (Type + Predicate), e.g., `PositiveInteger = Int where x > 0`.

**Acceptance Criteria**:
- Refinement types are declarable in the LDM
- Predicate violations produce errors (not silent coercion)
- Refinement types compose with other type constructors

**Traces To**: INT-001, INT-002 (Axiom 7)

---

### REQ-F-TYP-003: Error Domain Semantics (Either Monad)

**Priority**: Critical
**Type**: Functional

**Description**: Failures must be handled via Either Monad (`Left(Error) | Right(Value)`). Invalid records are routed to the Error Domain, never silently dropped.

**Acceptance Criteria**:
- Every morphism produces `Either[Error, Value]`
- Failures do not short-circuit unless batch threshold exceeded
- All invalid records reach the Error Sink with full context

**Traces To**: INT-001, INT-002 (Axiom 10)

---

### REQ-F-TYP-004: Idempotent Error Handling

**Priority**: High
**Type**: Functional

**Description**: Re-processing the same failing records under the same conditions must produce the same error results.

**Acceptance Criteria**:
- Error handling is deterministic
- Same failing input + same config = same error output
- No non-deterministic side effects in error routing

**Traces To**: INT-001, INT-002 (Axiom 10)

---

### REQ-F-TYP-005: No Implicit Casting

**Priority**: Critical
**Type**: Functional

**Description**: All type changes must be expressed as explicit morphisms. Implicit casting is forbidden.

**Acceptance Criteria**:
- No implicit type conversions exist
- All conversions are declared as named morphisms
- Undeclared type mismatches are rejected at compile time

**Traces To**: INT-001, INT-002 (Axiom 7)

---

### REQ-F-TYP-006: Type Unification Rules

**Priority**: Critical
**Type**: Functional

**Description**: When composing morphisms, codomain of first must equal domain of second (or be a subtype). Otherwise, composition is rejected.

**Acceptance Criteria**:
- Exact type match allows composition
- Subtype relationship allows composition
- Neither condition met: composition rejected with type error
- No implicit coercion (REQ-F-TYP-005 applies)

**Traces To**: INT-001, INT-002 (Axiom 7)

---

### REQ-F-TYP-007: Semantic Type Enforcement (Optional)

**Priority**: Medium
**Type**: Functional

**Description**: The type system may support semantic type distinctions (Money, Date, Percent). If defined, operations between incompatible semantic types must be rejected.

**Acceptance Criteria**:
- Semantic types are declarable
- Incompatible semantic type operations are rejected (e.g., Money + Date)
- Conversions require explicit morphisms

**Traces To**: INT-001, INT-002 (Axiom 7)

---

### REQ-F-ERR-001: Minimal Error Object Content

**Priority**: Critical
**Type**: Functional

**Description**: Each error object must include: failed constraint type, offending values, source entity and epoch, morphism path where failure occurred.

**Acceptance Criteria**:
- Error objects contain all four required fields
- Error objects are structured (not free-text)
- Error objects are routable to Error Sink

**Traces To**: INT-001, INT-002 (Axiom 10)

---

## 6. AI Assurance

### REQ-F-AI-001: Topological Validity Check

**Priority**: Critical
**Type**: Functional

**Description**: The engine must validate AI-generated mappings using the same structural rules as human-authored mappings. Reject hallucinated relationships, type violations, grain violations, and access violations.

**Acceptance Criteria**:
- AI-generated mappings pass through the same validation as human mappings
- Hallucinated morphisms (not in LDM) are rejected
- Type, grain, and access violations are rejected
- No special fast-path for AI-generated code

**Traces To**: INT-004, INT-002 (Axiom 8)

---

### REQ-F-AI-002: Triangulation of Assurance

**Priority**: High
**Type**: Functional

**Description**: The system must link Intent, Logic, and Proof for real-time verification.

**Acceptance Criteria**:
- Intent-to-Logic mapping is traceable
- Logic-to-Proof mapping is traceable (lineage graph, execution trace, type unification report)
- Proof-to-Intent validation is automated

**Traces To**: INT-004

---

### REQ-F-AI-003: Real-Time Dry Run

**Priority**: High
**Type**: Functional

**Description**: The system must support dry-run mode: execute validation and planning without committing results.

**Acceptance Criteria**:
- Dry-run produces validation results and execution plan
- No side effects (no data written to sinks)
- Dry-run results indicate pass/fail with specific diagnostics

**Traces To**: INT-004

---

## 7. Record Accounting

### REQ-F-ACC-001: Accounting Invariant

**Priority**: Critical
**Type**: Functional

**Description**: Every input record must be accounted for in exactly one output partition: processed, filtered, errored, or aggregated.

**Acceptance Criteria**:
- `|input_keys| = |reverse_join_keys| + |filtered_keys| + |error_keys|`
- No record appears in multiple partitions (mutual exclusivity)
- No record is unaccounted (completeness)
- Verification runs before marking a run COMPLETE

**Traces To**: INT-005

---

### REQ-F-ACC-002: Accounting Ledger

**Priority**: Critical
**Type**: Functional

**Description**: Each run must produce a `ledger.json` proving the accounting invariant holds.

**Acceptance Criteria**:
- Ledger contains input record count and source key field
- Ledger contains partition breakdown with adjoint metadata locations
- Ledger contains verification status (balanced/unbalanced)
- Ledger is written atomically at run completion

**Traces To**: INT-005

---

### REQ-F-ACC-003: Adjoint Key Capture

**Priority**: Critical
**Type**: Functional

**Description**: All morphisms must capture source keys in appropriate adjoint metadata.

**Acceptance Criteria**:
- Aggregations: contributing source keys captured in ReverseJoinMetadata
- Filters: excluded keys captured in FilteredKeysMetadata
- Errors: error records capture source_key
- Explodes (1:N): parent-child mapping captured
- Adjoint metadata is persistent (not ephemeral)

**Traces To**: INT-005

---

### REQ-F-ACC-004: Run Completion Gate

**Priority**: Critical
**Type**: Functional

**Description**: A run cannot be marked COMPLETE unless the accounting invariant verification passes.

**Acceptance Criteria**:
- Verification runs automatically before COMPLETE status
- Pass: emit OpenLineage COMPLETE event with ledger reference
- Fail: set FAILED status, emit FAIL event with discrepancy details
- Ledger is persisted regardless of pass/fail

**Traces To**: INT-005

---

### REQ-F-ACC-005: Backward Traversal Proof

**Priority**: High
**Type**: Functional

**Description**: Any output record must be traceable back to source records via adjoint metadata without recomputation.

**Acceptance Criteria**:
- Aggregate key retrieves contributing source keys
- Filtered key confirms intentional exclusion
- Error key retrieves original record and failure reason
- Backward traversal is deterministic

**Traces To**: INT-005

---

## 8. Non-Functional Requirements

### REQ-NFR-PERF-001: Distributed Execution

**Priority**: Critical
**Type**: Non-Functional

**Description**: The engine must execute on distributed compute frameworks (Spark, Flink, etc.).

**Acceptance Criteria**:
- Morphisms execute in parallel across cluster nodes
- Data partitioning is managed by the framework
- No single-node bottlenecks for standard operations

**Traces To**: INT-001

---

### REQ-NFR-PERF-002: Skew Mitigation

**Priority**: High
**Type**: Non-Functional

**Description**: The engine must mitigate data skew for 1:N expansions (salted joins or equivalent).

**Acceptance Criteria**:
- Whale keys are detected via sampling
- Salted join strategy distributes skewed keys
- No single-executor overload for skewed data

**Traces To**: INT-001

---

### REQ-NFR-SEC-001: Immutability of Business Logic

**Priority**: High
**Type**: Non-Functional

**Description**: Business logic morphisms must be pure functions with immutable inputs.

**Acceptance Criteria**:
- No mutable state in morphism execution
- Inputs are never modified in place
- Side effects are confined to Writer monad (telemetry)

**Traces To**: INT-002 (Axiom 6)

---

### REQ-NFR-OBS-001: OpenLineage Support

**Priority**: High
**Type**: Non-Functional

**Description**: The system must emit OpenLineage events for observability and lineage integration.

**Acceptance Criteria**:
- START, COMPLETE, and FAIL events are emitted per OpenLineage spec
- Lineage facets include source and target datasets
- Custom facets capture CDME-specific metadata (grain, type, adjoint)

**Traces To**: INT-001

---

### REQ-NFR-REG-001: Regulatory Compliance Package

**Priority**: High
**Type**: Non-Functional

**Description**: The system must generate an audit package containing versioned LDM topology, PDM bindings, logic artifacts, lineage graph, and execution trace.

**Acceptance Criteria**:
- All artifacts are versioned
- Package is self-contained and reconstructable
- Auditor can trace any output value to source inputs
- Package satisfies BCBS 239 Principles 3, 4, 6

**Traces To**: INT-001, INT-004

---

## 9. Data Quality Requirements

### REQ-DATA-BATCH-001: Batch Failure Threshold

**Priority**: High
**Type**: Data Quality

**Description**: The execution artifact may define a batch failure threshold (absolute count or percentage). Exceeding the threshold halts execution.

**Acceptance Criteria**:
- Threshold is configurable per job (absolute count or percentage)
- Exceeding threshold halts processing
- Commit/rollback of successful records is configurable
- Error Domain contains all failures prior to halt

**Traces To**: INT-001, INT-002 (Axiom 10)

---

### REQ-DATA-BATCH-002: Probabilistic Circuit Breaker

**Priority**: Medium
**Type**: Data Quality

**Description**: The engine must distinguish structural/configuration errors from genuine data quality errors via early sampling.

**Acceptance Criteria**:
- Early-stage failure rate is sampled
- If failure rate exceeds threshold (e.g., 5% of first 10k rows), halt with config error
- Structural errors do not flood the DLQ

**Traces To**: INT-001

---

## Summary

| Category | Count | Priority Distribution |
|----------|-------|----------------------|
| Functional (F) | 37 | 17 Critical, 14 High, 6 Medium |
| Non-Functional (NFR) | 4 | 1 Critical, 3 High |
| Data Quality (DATA) | 2 | 1 High, 1 Medium |
| **Total** | **43** | |

### REQ Key Cross-Reference to Intent

| Intent | REQ Keys |
|--------|----------|
| INT-001 | REQ-F-LDM-001..006, REQ-F-PDM-001..005, REQ-F-TRV-001..006, REQ-F-SHF-001, REQ-F-INT-001..008, REQ-F-TYP-001..007, REQ-F-ERR-001, REQ-NFR-PERF-001..002, REQ-NFR-SEC-001, REQ-NFR-OBS-001, REQ-NFR-REG-001, REQ-DATA-BATCH-001..002 |
| INT-002 | REQ-F-LDM-001..006, REQ-F-PDM-001..003, REQ-F-TRV-001..005, REQ-F-SHF-001, REQ-F-INT-001..006, REQ-F-TYP-001..007, REQ-F-ERR-001, REQ-F-AI-001, REQ-NFR-SEC-001 |
| INT-003 | REQ-F-INT-008 |
| INT-004 | REQ-F-AI-001..003, REQ-NFR-REG-001 |
| INT-005 | REQ-F-ACC-001..005, REQ-F-INT-003 |
| INT-006 | Deferred to design phase |
