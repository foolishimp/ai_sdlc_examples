# ADR-007: Multi-Module sbt Structure

**Status**: Accepted
**Date**: 2026-02-23
**Implements**: REQ-LDM-01 (module isolation), REQ-PDM-01 (LDM/PDM separation)

## Context

The CDME is a complex system with multiple concerns: pure domain model, compilation/validation, runtime execution, Spark binding, lineage, adjoint/backward traversal, public API, and external calculator support. These concerns have distinct dependency profiles:

- The domain model should have zero external dependencies
- The Spark binding depends on Spark (provided scope)
- The lineage module depends on OpenLineage
- The adjoint module depends only on the domain model
- The API module depends on all other modules

Without module boundaries, all dependencies become transitive, the domain model gets polluted with Spark types, and testing becomes slow (every test requires Spark).

## Decision

Structure the project as an **8-module sbt multi-project build** with a strict layered DAG of dependencies.

### Module DAG

```
cdme-model        (zero deps)
    |
    +---- cdme-compiler  (depends: model)
    |         |
    |         +---- cdme-runtime  (depends: compiler)
    |                   |
    |                   +---- cdme-spark    (depends: runtime, Spark provided)
    |                   +---- cdme-lineage  (depends: runtime, OpenLineage)
    |                   +---- cdme-external (depends: runtime)
    |
    +---- cdme-adjoint   (depends: model)
    |
    +---- cdme-api       (depends: all above)
```

### Build Configuration

```scala
// build.sbt (root)
lazy val commonSettings = Seq(
  scalaVersion := "2.13.12",
  organization := "com.cdme",
  scalacOptions ++= Seq(
    "-Xlint:_",
    "-Xfatal-warnings",
    "-deprecation",
    "-unchecked"
  )
)

lazy val model = (project in file("cdme-model"))
  .settings(commonSettings)
  // Zero external dependencies

lazy val compiler = (project in file("cdme-compiler"))
  .dependsOn(model)
  .settings(commonSettings)

lazy val runtime = (project in file("cdme-runtime"))
  .dependsOn(compiler)
  .settings(commonSettings)

lazy val spark = (project in file("cdme-spark"))
  .dependsOn(runtime)
  .settings(commonSettings)
  .settings(
    libraryDependencies += "org.apache.spark" %% "spark-sql" % "3.5.0" % Provided
  )

lazy val lineage = (project in file("cdme-lineage"))
  .dependsOn(runtime)
  .settings(commonSettings)
  .settings(
    libraryDependencies += "io.openlineage" % "openlineage-java" % "1.6.0"
  )

lazy val adjoint = (project in file("cdme-adjoint"))
  .dependsOn(model)
  .settings(commonSettings)

lazy val external = (project in file("cdme-external"))
  .dependsOn(runtime)
  .settings(commonSettings)

lazy val api = (project in file("cdme-api"))
  .dependsOn(compiler, runtime, spark, lineage, adjoint, external)
  .settings(commonSettings)

lazy val root = (project in file("."))
  .aggregate(model, compiler, runtime, spark, lineage, adjoint, external, api)
```

### Dependency Rules

1. **cdme-model has zero external dependencies** — Only Scala stdlib. This ensures the domain model is portable and fast to compile/test.
2. **cdme-compiler depends on cdme-model only** — Compilation/validation logic does not need runtime or Spark.
3. **cdme-spark depends on cdme-runtime, never on cdme-compiler internals** — The Spark layer receives a `ValidatedPlan` and executes it; it does not perform compilation.
4. **cdme-adjoint depends on cdme-model only** — Adjoint types and composition logic are pure math; they do not need the compiler or runtime.
5. **No circular dependencies** — The DAG is strictly acyclic.
6. **No global mutable state** — Each module exposes traits and case classes, not singletons.

## Consequences

### Positive

- **Fast unit tests**: Tests for cdme-model and cdme-adjoint run without Spark, completing in seconds
- **Clear dependency boundaries**: Impossible to accidentally import Spark types in the domain model
- **Independent releases**: Each module can be versioned and published independently (future)
- **Parallel compilation**: sbt compiles independent modules in parallel
- **Substitutability**: cdme-spark could be replaced with cdme-flink without affecting cdme-model, cdme-compiler, or cdme-adjoint
- **Clean architecture**: Dependencies flow in one direction (model <- compiler <- runtime <- spark)

### Negative

- 8 modules create sbt overhead: more `build.sbt` configuration, longer initial project load
- Cross-module refactoring requires changes in multiple modules
- Integration testing requires assembling multiple modules together
- Developers must understand the module DAG to know where to put new code

### Risks

- Module proliferation: if future requirements add more concerns, the module count could grow unwieldy. Mitigation: the current 8 modules cover all 75 requirements; new modules should only be added for genuinely orthogonal concerns.
- sbt inter-project dependency resolution can be slow for incremental compilation. Mitigation: use sbt 1.9+ with zinc incremental compiler.

## Alternatives Considered

1. **Single module** — Simplest structure but loses all dependency isolation benefits. Rejected.
2. **3 modules (model, engine, spark)** — Fewer modules but blurs the compiler/runtime boundary and forces lineage and adjoint into the engine. Rejected.
3. **Maven multi-module** — sbt is the standard Scala build tool with better incremental compilation. Rejected.
4. **Mill build tool** — Faster builds but less ecosystem support than sbt. Rejected for maturity reasons.

## References

- [ADR-001](ADR-001.md) — Sealed ADT Type System (cdme-model types)
- [ADR-006](ADR-006.md) — Spark Integration Strategy (cdme-spark module)
- [ADR-013](ADR-013.md) — Scala 2.13 over Scala 3 (impacts sbt configuration)
- REQ-LDM-01 — Strict Graph Structure (core model)
- REQ-PDM-01 — Functorial Mapping (LDM/PDM separation)
- CLAUDE.md — Architecture section (module dependency rules)
