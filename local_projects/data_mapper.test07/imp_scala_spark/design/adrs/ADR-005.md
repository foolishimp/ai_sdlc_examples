# ADR-005: Grain Ordering System

**Status**: Accepted
**Date**: 2026-02-23
**Implements**: REQ-LDM-06, REQ-TRV-02, REQ-INT-02, REQ-INT-05

## Context

The CDME specification treats Grain as a formal dimension property (Axiom 5): "Mixing grains without explicit aggregation is topologically forbidden." This is not merely documentation — the compiler must enforce grain safety at definition/compile time (REQ-TRV-02).

The grain system must support:

1. A total ordering on grains (e.g., Atomic < Daily < Monthly < Quarterly < Yearly)
2. Compile-time detection of grain mixing violations
3. Multi-level aggregation along the grain hierarchy (REQ-INT-02)
4. Custom grains (domain-specific granularities beyond the defaults)
5. Grain alignment in cross-domain covariance contracts (REQ-COV-06)

## Decision

Model grains as a **sealed trait with an integer level for total ordering**, plus support for custom grains.

```scala
sealed trait Grain extends Ordered[Grain] {
  def level: Int
  override def compare(that: Grain): Int = this.level - that.level
}

object Grain {
  case object Atomic    extends Grain { val level = 0 }
  case object Daily     extends Grain { val level = 1 }
  case object Monthly   extends Grain { val level = 2 }
  case object Quarterly extends Grain { val level = 3 }
  case object Yearly    extends Grain { val level = 4 }
  case class Custom(name: String, level: Int) extends Grain
}
```

### Total Order

Grains form a total order via the `Ordered[Grain]` trait. This enables:
- `grain1 < grain2` — grain1 is finer than grain2
- `grain1 > grain2` — grain1 is coarser than grain2
- `grain1 == grain2` — same grain level

### Grain Hierarchy

The `GrainHierarchy` in the `Category` defines which aggregation paths are valid:

```scala
final case class GrainHierarchy(
    grains: List[Grain],
    aggregationPaths: Map[(Grain, Grain), List[Grain]]
)
```

For example, `(Atomic, Yearly) -> [Atomic, Daily, Monthly, Quarterly, Yearly]` means aggregation from Atomic to Yearly must pass through Daily, then Monthly, then Quarterly.

### Grain Safety Rules

The compiler (`GrainChecker`) enforces three rules:

1. **No cross-grain projection**: Two attributes in the same output entity must have compatible grains. Compatible means: same grain, or one is explicitly aggregated to the other's level.

2. **No cross-grain expressions**: An arithmetic or string expression cannot combine attributes from different grains without wrapping the finer-grained attribute in an explicit aggregation morphism.

3. **No cross-grain joins without aggregation**: Joining entity A (grain G1) with entity B (grain G2) where G1 != G2 requires an explicit aggregation morphism in the mapping path that bridges the grain gap.

### Multi-Level Aggregation

Multi-level aggregation (REQ-INT-02) is permitted when:
1. Each level's aggregation function satisfies monoid laws (REQ-LDM-04)
2. The grain hierarchy defines a valid path between the source and target grains
3. The mapping explicitly encodes each aggregation step as a separate morphism

## Consequences

### Positive

- Total ordering enables simple, efficient grain comparison using standard Scala comparison operators
- Compile-time grain safety prevents a major class of data pipeline errors (silent grain mixing)
- Custom grains allow domain-specific granularities without modifying the core code
- The grain hierarchy explicitly encodes valid aggregation paths, making multi-level aggregation transparent
- Grain metadata is first-class on entities, not hidden in documentation

### Negative

- Total ordering assumes grains are linearly ordered. Some domains may have grain lattices (e.g., geographic grains: City < State, City < Region where State and Region are incomparable). Mitigation: for the current requirements, a total order suffices. Future versions could extend to a partial order.
- Custom grains with arbitrary levels could create ambiguous orderings if not carefully managed. Mitigation: the `GrainHierarchy` is the authoritative ordering; the integer `level` is for default sorting only.

### Risks

- If domains require non-linear grain hierarchies (e.g., temporal x geographic), the total order model becomes insufficient. This is a known limitation documented in Source Findings.
- The `Custom` grain variant is not sealed, meaning any code can create new grains. Mitigation: the `GrainHierarchy` in the `Category` must explicitly register all valid grains.

## Alternatives Considered

1. **Enumeration without ordering** — Grains as simple labels without ordering. Rejected because the compiler needs ordering to validate aggregation direction (finer -> coarser).
2. **Partial order (lattice)** — More general but adds complexity for composition checking. Deferred to future versions if multi-dimensional grains are required.
3. **Phantom types for grains** — `Entity[Atomic]`, `Entity[Daily]`, etc. Provides compile-time safety but is not compatible with runtime-loaded LDMs where grain information comes from YAML/JSON configuration. Rejected.

## References

- [ADR-002](ADR-002.md) — Category Representation (GrainHierarchy in Category)
- [ADR-004](ADR-004.md) — Adjoint Morphism Design (adjoint respects grain)
- [ADR-006](ADR-006.md) — Spark Integration Strategy (grain in Spark schema)
- REQ-LDM-06 — Grain & Type Metadata
- REQ-TRV-02 — Grain Safety
- REQ-INT-02 — Subsequent Aggregation
- REQ-INT-05 — Multi-Grain Formulation
- REQ-COV-06 — Multi-Grain Fidelity
- Specification Axiom 5 — Grain is a Dimension
