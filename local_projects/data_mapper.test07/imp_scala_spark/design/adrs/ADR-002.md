# ADR-002: Category Representation

**Status**: Accepted
**Date**: 2026-02-23
**Implements**: REQ-LDM-01, REQ-LDM-02, REQ-LDM-06

## Context

The CDME specification requires the Logical Data Model (LDM) to be a directed multigraph (REQ-LDM-01) where entities are objects and relationships are morphisms. Each morphism has cardinality metadata (REQ-LDM-02), each entity carries grain and type metadata (REQ-LDM-06), and the topology must be queryable and traversable programmatically.

We need a Scala representation that:

1. Is immutable (functional paradigm constraint)
2. Supports O(1) entity and morphism lookup by ID
3. Supports multigraph semantics (multiple edges between same entity pair)
4. Carries identity morphism per entity (category law)
5. Stores grain hierarchy for validation
6. Is serializable to/from YAML or JSON for configuration artifacts

## Decision

Represent categories as **immutable case classes with `Map`-based storage** for entities and morphisms, keyed by typed IDs.

```scala
final case class Category(
    name: String,
    entities: Map[EntityId, Entity],
    morphisms: Map[MorphismId, Morphism],
    grainHierarchy: GrainHierarchy
)
```

### Design Choices

1. **Map[EntityId, Entity]** for O(1) lookup. EntityId and MorphismId are value classes wrapping `String` for type safety:
   ```scala
   final case class EntityId(value: String) extends AnyVal
   final case class MorphismId(value: String) extends AnyVal
   ```

2. **Multigraph support**: Multiple morphisms between the same entity pair have distinct MorphismIds. The `Map[MorphismId, Morphism]` naturally supports this since each morphism has a unique key.

3. **Identity morphism**: Every entity references its identity morphism ID. The identity morphism is stored in the morphisms map like any other morphism, with `domain == codomain == entityId` and `cardinality == OneToOne`.

4. **Immutability**: The `Category` case class is fully immutable. Building a category uses the `CategoryBuilder` (cdme-api) which accumulates entities and morphisms, then produces an immutable `Category` instance via `build()`.

5. **Adjacency queries**: Traversal queries (e.g., "find all morphisms from entity A") are computed via filtering the morphisms map. For frequently used queries, the compiler may precompute adjacency indices during compilation into the `ValidatedPlan`.

## Consequences

### Positive

- Immutable representation prevents mutation bugs and is safe for concurrent access
- O(1) lookup by ID for both entities and morphisms
- Multigraph is naturally supported without special data structures
- Case class equality makes category comparison trivial
- Serialization to/from YAML is straightforward via standard libraries
- The representation maps cleanly to the specification's ontology (Section 3)

### Negative

- Adjacency queries (e.g., "all outgoing morphisms from entity X") require scanning the morphisms map — O(n) in number of morphisms. Mitigation: precompute adjacency lists during compilation.
- Updating a single entity in a large category creates a new Map copy. Scala's persistent data structures make this O(log n), but it is still slower than mutable maps. Mitigation: categories are built once and read many times.

### Risks

- Very large LDMs (10,000+ entities, 100,000+ morphisms) may cause memory pressure with immutable maps. Mitigation: such LDMs are uncommon; if needed, switch to mutable builder pattern internally during construction, then freeze to immutable.

## Alternatives Considered

1. **Graph library (e.g., JGraphT)** — Provides rich graph algorithms but introduces a mutable, Java-centric dependency. Rejected for immutability and Scala idiom reasons.
2. **Adjacency list representation** — More efficient for traversal queries but complicates lookup by ID. Rejected in favor of the dual (Map + precomputed adjacency).
3. **Type-level graph encoding (shapeless)** — Provides compile-time graph validation but is impractical for runtime-loaded LDMs. Rejected.

## References

- [ADR-001](ADR-001.md) — Sealed ADT Type System (Entity attribute types)
- [ADR-005](ADR-005.md) — Grain Ordering System (GrainHierarchy in Category)
- [ADR-007](ADR-007.md) — Multi-Module sbt Structure (cdme-model module)
- REQ-LDM-01 — Strict Graph Structure
- REQ-LDM-02 — Cardinality Types
- REQ-LDM-06 — Grain & Type Metadata
- Specification Section 3.1 — The Objects (Entities)
- Specification Section 3.2 — The Morphisms (Relationships & Logic)
