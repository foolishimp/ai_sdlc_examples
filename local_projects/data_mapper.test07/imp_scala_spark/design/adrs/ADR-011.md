# ADR-011: Context and Epoch Management

**Status**: Accepted
**Date**: 2026-02-23
**Implements**: REQ-SHF-01, REQ-TRV-03, REQ-PDM-02, REQ-PDM-02-A, REQ-PDM-03, REQ-INT-06, REQ-TRV-05

## Context

The CDME specification (Axiom 4) states that "Data Has Contextual Extent" — data exists only within a specific Context (Epoch/Batch). The system borrows sheaf-theoretic intuitions:

- **Local consistency**: Data within a Contextual Fiber (Entity, Epoch, Partition) is coherent
- **Gluing constraints**: Joins are only allowed between compatible fibers
- **Temporal semantics**: Cross-boundary traversals must declare temporal semantics (REQ-TRV-03)

Additionally:
- Reference data must be versioned and immutable within execution context (Axiom 6, REQ-INT-06)
- Physical sources declare generation grain: Event or Snapshot (REQ-PDM-02)
- Boundaries slice continuous data into epochs (REQ-PDM-03)
- Execution must be deterministically reproducible (REQ-TRV-05)

## Decision

Model context and epoch management as explicit, first-class components in the runtime.

### Epoch Model

```scala
/** An Epoch represents a bounded temporal window of data. */
final case class Epoch(
    id: EpochId,
    start: java.time.Instant,
    end: java.time.Instant,
    generationGrain: GenerationGrain,
    boundary: BoundaryDefinition
)

/** A Contextual Fiber: the unit of data coherence. */
final case class ContextualFiber(
    entity: EntityId,
    epoch: Epoch,
    partitionKey: Option[String]
)
```

### Temporal Semantics

Cross-boundary traversals (REQ-TRV-03) must declare one of:

```scala
sealed trait TemporalSemantics
object TemporalSemantics {
  /** Use data as-of a specific point in time. */
  case class AsOf(timestamp: java.time.Instant) extends TemporalSemantics

  /** Use the latest available version. Deterministic within epoch. */
  case object Latest extends TemporalSemantics

  /** Require exact epoch match. */
  case object Exact extends TemporalSemantics
}
```

The compiler validates that cross-boundary traversals have declared temporal semantics. Traversals without temporal semantics are rejected (REQ-TRV-03 acceptance criterion 4).

### Context Manager

```scala
trait ContextManager {
  /** Validate that two fibers are compatible for joining. */
  def validateFiberCompatibility(
      left: ContextualFiber,
      right: ContextualFiber,
      temporalSemantics: Option[TemporalSemantics]
  ): Either[CdmeError, Unit]

  /** Resolve lookup version for the given epoch. */
  def resolveLookupVersion(
      lookupId: LookupId,
      epoch: Epoch,
      versionSpec: LookupVersionSpec
  ): Either[CdmeError, LookupVersion]
}
```

### Fiber Compatibility Rules (REQ-SHF-01)

Two fibers are compatible for joining if:

1. **Same epoch**: Both fibers share the same `EpochId` — always compatible
2. **Declared temporal semantics**: Different epochs with explicit `TemporalSemantics` — compatible if the semantics resolve to valid data
3. **Compatible partitioning**: Same partition key, or one side is global (no partition key)

If none of these hold, the join is rejected at compile time.

### Lookup Versioning (REQ-INT-06)

Within a single execution context:
- Same lookup + same key always returns same value (immutability within context)
- Lookup versions are resolved at context initialization and frozen for the duration
- Lookup versions are recorded in the `RunManifest` for reproducibility
- Unversioned lookups cause mapping rejection

### Generation Grain Semantics (REQ-PDM-02-A)

The generation grain affects how boundaries slice data:

- **Event**: Immutable occurrences sliced by temporal windows. An event's epoch is determined by its timestamp falling within the boundary window.
- **Snapshot**: State at a point in time. Each snapshot supersedes prior states. A snapshot's epoch is the as-of version.

### Execution Context

The `ExecutionContext` aggregates all context:

```scala
final case class ExecutionContext(
    runId: RunId,
    epoch: Epoch,
    lookupVersions: Map[LookupId, LookupVersion],
    lineageMode: LineageMode,
    failureThreshold: FailureThreshold,
    dryRun: Boolean,
    runManifest: RunManifest
)
```

This is immutable once created. All operations within a single execution reference the same context, ensuring deterministic reproducibility (REQ-TRV-05).

## Consequences

### Positive

- Epoch/context is explicit, not implicit — prevents the common ETL bug of accidentally joining data across time boundaries
- Temporal semantics must be declared, not assumed — forces developers to think about temporal correctness
- Lookup immutability within context ensures determinism
- The context model maps cleanly to the specification's sheaf-like semantics
- The `RunManifest` captures everything needed to reproduce a run

### Negative

- Explicit temporal semantics add verbosity to mapping definitions
- Epoch management adds complexity to the Spark binding (epoch-aware source loading)
- The `Latest` temporal semantics introduces a potential non-determinism window (between epoch creation and execution start). Mitigation: resolve `Latest` to a concrete version at context initialization time.

### Risks

- Clock skew between systems may cause epoch boundary misalignment. Mitigation: epochs use server-side timestamps; clock synchronization is a deployment concern.
- Very large temporal binding maps (thousands of epochs x hundreds of entities) may cause memory pressure. Mitigation: lazy resolution — only load physical targets for epochs actually accessed.

## Alternatives Considered

1. **Implicit epoch from data timestamps** — Infer epochs from data. Loses control over boundary semantics and complicates reproducibility. Rejected.
2. **Global execution context (singleton)** — Simpler but prevents concurrent executions with different epochs. Rejected.
3. **Full sheaf implementation** — Formal restriction maps and gluing axioms. Overkill per the specification: "the engine does not require a full topological space structure." Rejected.
4. **Epoch-free execution** — Process all data without temporal boundaries. Violates Axiom 4 and REQ-SHF-01. Rejected.

## References

- [ADR-003](ADR-003.md) — Either-Based Error Handling (context validation errors)
- [ADR-005](ADR-005.md) — Grain Ordering System (grain within epoch)
- [ADR-006](ADR-006.md) — Spark Integration Strategy (epoch-aware source loading)
- [ADR-009](ADR-009.md) — OpenLineage Integration (epoch in lineage events)
- REQ-SHF-01 — Sheaf / Context Consistency
- REQ-TRV-03 — Boundary Alignment & Temporal Semantics
- REQ-PDM-02 — Generation Grain
- REQ-PDM-02-A — Generation Grain Semantics
- REQ-PDM-03 — Boundary Definition
- REQ-INT-06 — Versioned Lookups
- REQ-TRV-05 — Deterministic Reproducibility
- Specification Axiom 4 — Data Has Contextual Extent
- Specification Axiom 6 — Lookups are Arguments
- Specification Section 3.3 — Sheaf-like Contextual Extent
