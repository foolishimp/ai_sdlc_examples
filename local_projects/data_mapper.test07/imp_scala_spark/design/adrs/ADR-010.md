# ADR-010: External Calculator Registry

**Status**: Accepted
**Date**: 2026-02-23
**Implements**: REQ-INT-08

## Context

The CDME specification (INT-003, Axiom 9) states that "Calculations are Morphisms" — any computation, from a simple field rename to a Monte Carlo simulation, is a standard morphism in the topology. REQ-INT-08 requires support for "Black Box Calculators" (e.g., compiled cashflow engines, risk models) as first-class morphisms.

These external calculators have specific constraints:
1. They declare domain and codomain types conforming to the LDM type system
2. The registrant asserts determinism (same inputs -> same outputs) as a contract
3. They have a stable identifier/version for lineage tracing
4. Type compatibility is enforced at compile time (REQ-TYP-06)
5. The CDME does NOT runtime-verify determinism — it trusts the contract

The challenge is integrating arbitrary external code into the CDME's type-safe, lineage-tracked pipeline without compromising the system's guarantees.

## Decision

Implement an `ExternalCalculatorRegistry` that manages the lifecycle of external calculator registration, type validation, invocation, and lineage tracking.

### Registration Model

```scala
final case class ExternalCalculator(
    id: CalculatorId,
    name: String,
    version: String,
    domainType: CdmeType,
    codomainType: CdmeType,
    determinismAssertion: Boolean,
    metadata: Map[String, String]
)

trait ExternalCalculatorRegistry {
  def register(calculator: ExternalCalculator): Either[CdmeError, Unit]
  def lookup(id: CalculatorId): Either[CdmeError, ExternalCalculator]
  def invoke[A, B](id: CalculatorId, input: A): Either[CdmeError, B]
}
```

### Type Enforcement

At registration time, the registry validates that `domainType` and `codomainType` are valid `CdmeType` instances. At compile time, the `TopologicalValidator` checks that morphisms referencing external calculators have type-compatible connections:

```
preceding_morphism.codomain unifies with calculator.domainType  (REQ-TYP-06)
calculator.codomainType unifies with following_morphism.domain   (REQ-TYP-06)
```

### Determinism Contract

The `determinismAssertion` flag is a **trust-based contract**:
- If `true`, the CDME trusts that `invoke(id, input) == invoke(id, input)` for identical inputs
- This trust enables deterministic reproducibility (REQ-TRV-05) for pipelines containing external calculators
- The CDME does NOT runtime-verify determinism
- The calculator version is logged in lineage (REQ-INT-03) so that changes can be detected via run comparison

### Morphism Adapter

External calculators are wrapped as standard morphisms:

```scala
trait ExternalMorphismAdapter {
  def asMorphism(calculator: ExternalCalculator): Morphism
  def asAdjoint(
      calculator: ExternalCalculator,
      backwardImpl: Option[Any => Either[CdmeError, Any]]
  ): Option[AdjointSpec]
}
```

The adapter creates a `Morphism` with:
- `domain` = synthetic entity matching `calculator.domainType`
- `codomain` = synthetic entity matching `calculator.codomainType`
- `morphismKind` = `MorphismKind.External`
- `adjoint` = `Some(Lossy)` if no backward is provided, or the declared backward if provided

### Lineage Integration

Every invocation of an external calculator is recorded in lineage:
- Calculator ID and version
- Input hash (for determinism verification if needed)
- Invocation timestamp
- Output hash

This enables:
- Auditors to see which calculator version produced which outputs
- Run comparison to detect calculator version changes
- Lineage-based impact analysis for calculator upgrades

## Consequences

### Positive

- External calculators become first-class citizens in the topology, subject to the same type safety and lineage tracking as native morphisms
- The trust-based determinism contract is pragmatic — verifying determinism of arbitrary code is undecidable in general
- Calculator versioning enables safe upgrades: run comparison shows behavioral changes
- The adapter pattern cleanly separates external code from CDME internals
- Supports the "Universal Applicability" goal (INT-003): cashflow engines, risk models, and Monte Carlo simulations all integrate the same way

### Negative

- Trust-based determinism means a non-deterministic calculator could silently break REQ-TRV-05. Mitigation: the lineage captures input/output hashes for optional offline verification.
- External calculators are black boxes — the CDME cannot optimize their execution (e.g., predicate pushdown, partitioning)
- Type declarations for external calculators must be manually maintained — if the calculator's actual types change, the CDME won't detect the mismatch until runtime
- No automatic adjoint for external calculators — backward must be explicitly provided or the morphism is classified as Lossy

### Risks

- External calculators may have side effects (file I/O, network calls) that violate the functional paradigm. Mitigation: this is the registrant's responsibility per the determinism contract.
- Version management for external calculators is outside CDME's control. Mitigation: the registry records versions; lineage makes version changes visible.

## Alternatives Considered

1. **No external calculator support** — Forces all logic into CDME morphisms. Impractical for complex domain calculations (cashflow engines are millions of lines of code). Rejected.
2. **UDF-only approach** — Register external code as Spark UDFs. Loses type safety and lineage tracking. Rejected.
3. **Runtime determinism verification** — Run each calculator twice and compare outputs. Doubles execution cost and is still not a proof (could be non-deterministic on different inputs). Rejected per specification: "the engine treats as a contract but does not independently verify at runtime."
4. **Containerized calculators (Docker/WASM)** — Provides isolation but adds latency and infrastructure complexity. Deferred to future consideration.

## References

- [ADR-001](ADR-001.md) — Sealed ADT Type System (type declarations for calculators)
- [ADR-003](ADR-003.md) — Either-Based Error Handling (calculator failures)
- [ADR-004](ADR-004.md) — Adjoint Morphism Design (Lossy classification for black-box)
- [ADR-007](ADR-007.md) — Multi-Module sbt Structure (cdme-external module)
- [ADR-009](ADR-009.md) — OpenLineage Integration (calculator version in lineage)
- REQ-INT-08 — External Computational Morphisms
- REQ-TYP-06 — Type Unification Rules (compile-time type checking)
- REQ-TRV-05 — Deterministic Reproducibility
- REQ-INT-03 — Traceability (lineage for calculator invocations)
- Specification Axiom 9 — Calculations are Morphisms
- Specification INT-003 — Universal Applicability
