# ADR-012: Public API Design

**Status**: Accepted
**Date**: 2026-02-23
**Implements**: REQ-AI-03, REQ-INT-04, REQ-COV-01, REQ-COV-02, REQ-DQ-01, REQ-DQ-02, REQ-DQ-03

## Context

The CDME is a complex system with multiple configuration artifacts (LDM, PDM, Mapping, Job Config), multiple phases (compile, execute, dry-run), and multiple integration points (lineage, fidelity, data quality). Users need a coherent API that:

1. Guides correct construction of configuration artifacts (prevent invalid states)
2. Provides clear entry points for compilation and execution
3. Supports dry-run mode for assurance before production (REQ-AI-03)
4. Enables complex business logic expressions (REQ-INT-04)
5. Supports covariance contracts for cross-domain fidelity (REQ-COV-01, REQ-COV-02)
6. Integrates data quality monitoring (REQ-DQ-01, REQ-DQ-02, REQ-DQ-03)

The API must be usable from both Scala code and potentially from a DSL or configuration files.

## Decision

Use the **Builder pattern** for constructing configuration artifacts and a **Facade** for the execution lifecycle.

### Builder Pattern for Artifacts

Each configuration artifact has a dedicated builder that:
- Accepts incremental additions
- Validates constraints at `build()` time
- Returns `Either[CdmeError, Artifact]` (ADR-003)

```scala
// LDM Construction
val category = new CategoryBuilder()
  .withEntity(trade)
  .withEntity(counterparty)
  .withMorphism(tradeBelongsToCounterparty)
  .withGrainHierarchy(temporalHierarchy)
  .build()  // Either[CdmeError, Category]

// PDM Binding
val pdm = new PdmBuilder()
  .bindEntity(tradeId, parquetTarget, Event, dailyBoundary)
  .withLookup(fxRates)
  .withTemporalBinding(historicalTrades)
  .build()  // Either[CdmeError, PhysicalDataModel]

// Mapping Definition
val mapping = new MappingBuilder()
  .withSourcePath("Trade.belongs_to.Counterparty.name")
  .withSynthesis(fxConversion)
  .withConditional(priorityLogic)
  .withLookupVersion(fxRatesId, asOfEpoch)
  .build()  // Either[CdmeError, MappingDefinition]
```

### Facade for Execution Lifecycle

```scala
class CdmeEngine {
  /** Compile artifacts into a validated plan. */
  def compile(input: CompilationInput): Either[List[CdmeError], ValidatedPlan]

  /** Execute a validated plan with full lineage and accounting. */
  def execute(plan: ValidatedPlan, context: ExecutionContext): Either[CdmeError, ExecutionResult]

  /** Dry-run: compile + validate + estimate without writing outputs. */
  def dryRun(input: CompilationInput): Either[List[CdmeError], DryRunResult]
}
```

### Dry-Run Mode (REQ-AI-03)

`dryRun` performs compilation plus execution planning without committing results:

```scala
final case class DryRunResult(
    plan: ValidatedPlan,
    lineageGraph: LineageGraph,
    typeUnificationReport: TypeUnificationReport,
    costEstimate: CostEstimate,
    grainSafetyReport: GrainSafetyReport,
    profilingResults: Option[ProfilingResults]
)
```

This provides immediate assurance signals for AI-generated mappings (REQ-AI-01) and human review (REQ-AI-02).

### Complex Business Logic (REQ-INT-04)

The `MappingBuilder` supports advanced formulations:

```scala
// Conditional expressions
sealed trait SynthesisExpression
final case class ConditionalExpression(
    condition: Predicate,
    thenExpr: SynthesisExpression,
    elseExpr: SynthesisExpression
) extends SynthesisExpression

// Prioritized fallback
final case class FallbackExpression(
    alternatives: List[SynthesisExpression]
) extends SynthesisExpression

// Morphism composition
final case class ComposedExpression(
    steps: List[SynthesisExpression]
) extends SynthesisExpression

// Product/tuple construction
final case class ProductExpression(
    fields: Map[String, SynthesisExpression]
) extends SynthesisExpression
```

### Covariance Contract API (REQ-COV-01, REQ-COV-02)

```scala
val contract = new CovarianceContractBuilder()
  .withDomains(financeCategory, riskCategory)
  .withInvariant(FidelityInvariant.Conservation(
      "sum(finance.pnl) == sum(risk.mtm)", Grain.Daily))
  .withMaterialityThreshold(MaterialityThreshold.Absolute(0.01))
  .withEnforcementMode(EnforcementMode.Strict)
  .build()
```

### Data Quality Configuration (REQ-DQ-01, REQ-DQ-02, REQ-DQ-03)

Data quality is configured through the `JobConfiguration`:

```scala
val jobConfig = JobConfigurationBuilder()
  .withVolumeThreshold(VolumeThreshold(
      minRecords = Some(100000),
      maxRecords = Some(2000000),
      baselineWindow = Some(7),
      violationResponse = ViolationResponse.Halt))
  .withDistributionMonitor(DistributionMonitorConfig(
      fields = List("amount", "currency"),
      nullRateThreshold = Some(0.05),
      divergenceThreshold = Some(0.1)))
  .withCustomValidation(CustomValidationRule(
      id = "end_after_start",
      predicate = "end_date > start_date",
      severity = Severity.Error))
  .build()
```

## Consequences

### Positive

- Builder pattern prevents construction of invalid artifacts (validation at `build()` time)
- `Either` return types make error handling explicit (ADR-003)
- `dryRun` enables safe AI assurance without side effects
- The API is composable: builders can be passed around, extended, and combined
- Expression types support all required business logic formulations (conditionals, fallbacks, composition, products)
- Covariance contracts are first-class API citizens, not afterthoughts
- Data quality configuration integrates naturally with job configuration

### Negative

- Builder pattern is verbose compared to a DSL. Mitigation: a future DSL layer can wrap the builders.
- The API requires understanding the 4-artifact model (LDM, PDM, Mapping, JobConfig) before use. Mitigation: good documentation and examples.
- Expression types form a mini-language that needs its own compilation/evaluation. This is inherent complexity from the requirement.

### Risks

- The expression type hierarchy may need extension for unforeseen business logic patterns. Mitigation: `SynthesisExpression` is sealed within the package, but can be extended via the `ExternalCalculator` mechanism (ADR-010).
- The builder pattern accumulates state, which could lead to misuse (e.g., calling `build()` twice). Mitigation: builders are not thread-safe; document single-use pattern.

## Alternatives Considered

1. **Configuration file only (YAML/JSON)** — Less flexible for complex expressions. Rejected as primary API; supported as an alternative input format.
2. **Fluent API (method chaining with `this` return)** — Similar to builder but harder to compose. Builder is more idiomatic Scala.
3. **Free monad / DSL** — More powerful but harder to understand and debug. Deferred to future enhancement.
4. **Annotation-based API (macros)** — Compile-time DSL via Scala macros. Powerful but fragile and hard to maintain. Rejected.

## References

- [ADR-001](ADR-001.md) — Sealed ADT Type System (expression types)
- [ADR-003](ADR-003.md) — Either-Based Error Handling (builder returns Either)
- [ADR-007](ADR-007.md) — Multi-Module sbt Structure (cdme-api module)
- [ADR-011](ADR-011.md) — Context and Epoch Management (ExecutionContext in execute)
- REQ-AI-03 — Real-Time Dry Run
- REQ-INT-04 — Complex Business Logic
- REQ-COV-01 — Cross-Domain Covariance Contracts
- REQ-COV-02 — Fidelity Invariants
- REQ-DQ-01 — Volume Threshold Monitoring
- REQ-DQ-02 — Distribution Monitoring
- REQ-DQ-03 — Custom Validation Rules
- Specification Section 8.1 — Configuration Artifacts
