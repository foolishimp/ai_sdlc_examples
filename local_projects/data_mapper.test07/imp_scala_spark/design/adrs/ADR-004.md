# ADR-004: Adjoint Morphism Design

**Status**: Accepted
**Date**: 2026-02-23
**Implements**: REQ-ADJ-01, REQ-ADJ-02, REQ-ADJ-03, REQ-ADJ-04, REQ-ADJ-05, REQ-ADJ-06, REQ-ADJ-07, REQ-ADJ-08, REQ-ADJ-09, REQ-ADJ-10, REQ-ADJ-11

## Context

The CDME specification (INT-005) requires that every morphism `f: A -> B` has a corresponding backward morphism `f^-: B -> A` forming a Galois connection. This enables:

- **Data reconciliation** via `backward(forward(x)) supseteq x` (REQ-ADJ-08)
- **Impact analysis** via `backward(target_subset)` (REQ-ADJ-09)
- **Bidirectional sync** via single adjoint definition (REQ-ADJ-10)
- **Full backward lineage** without recomputation (REQ-ACC-05)

The adjoint system must handle the inherent information loss in aggregations, filters, and lossy transformations while maintaining compositional correctness.

Appendix A (Frobenius Algebras) suggests that aggregation/expansion pairs may benefit from a stronger algebraic structure, but recommends keeping `Adjoint` as the base interface.

## Decision

### 1. Core Adjoint Interface

Every morphism in the CDME implements or references an `Adjoint[A, B]` trait:

```scala
trait Adjoint[A, B] {
  def forward(a: A): Either[CdmeError, B]
  def backward(b: B): Either[CdmeError, Set[A]]
  def classification: AdjointClassification
}
```

The `backward` returns `Set[A]` (not a single `A`) because backward traversal through aggregations and filters naturally produces sets of contributing records.

### 2. Classification Hierarchy

Every adjoint is classified as one of four types (REQ-ADJ-02):

- **Isomorphism**: Exact round-trip (`f^-(f(x)) = x`)
- **Embedding**: Injective forward (`f^-(f(x)) = x`, `f(f^-(y)) subset y`)
- **Projection**: Surjective forward (`f^-(f(x)) supset x`, `f(f^-(y)) = y`)
- **Lossy**: Neither injective nor surjective

Classification is inferred for structural morphisms:
- `1:1` morphisms -> Isomorphism
- `N:1` morphisms -> Projection (many inputs map to one output)
- `1:N` morphisms -> Projection (parent expands to children; backward collapses)

### 3. Backward Strategies by Morphism Type

| Morphism | Forward | Backward | Metadata Captured | Classification |
|----------|---------|----------|-------------------|---------------|
| 1:1 (Isomorphism) | `f(x)` | `f^-1(y)` | None needed | Isomorphism |
| N:1 (Pure function) | `f(x)` | Preimage lookup | Reverse-join table | Projection |
| 1:N (Kleisli) | Expand | Collect parent | Parent-child map | Projection |
| Aggregation (Fold) | `groupBy.agg` | Reverse-join table | group_key -> source_keys | Projection |
| Filter | `filter(p, xs)` | Include filtered-out | passed + filtered keys | Embedding (if captured) |
| Hash/lossy transform | `hash(x)` | Not invertible | None | Lossy |

### 4. Metadata Capture During Forward Execution

Adjoint metadata is captured as a side-effect during forward execution, stored alongside the output:

- **AggregationAdjointCapture**: Records `group_key -> Set(contributing_source_keys)` in a reverse-join table
- **FilterAdjointCapture**: Records `Set(passed_keys)` and `Set(filtered_keys)`
- **KleisliAdjointCapture**: Records `child_key -> parent_key` mapping

Storage strategies (REQ-ADJ-11):
- **Inline**: Metadata in output dataset columns
- **Separate table**: Dedicated storage
- **Compressed**: Roaring Bitmaps for key sets, range encoding for sorted keys

Storage budget is configurable per job (default: max 20% of output size).

### 5. Contravariant Composition (REQ-ADJ-07)

Adjoint composition follows the contravariant rule:

```
(g . f)^- = f^- . g^-
```

Classification propagation:
```
compose(Isomorphism, Isomorphism) = Isomorphism
compose(Embedding, Embedding)     = Embedding
compose(Projection, Projection)   = Projection
compose(_, Lossy) | compose(Lossy, _) = Lossy
compose(Embedding, Projection)    = Lossy
compose(Projection, Embedding)    = requires case analysis
```

### 6. Frobenius Extension (Optional Layer)

Per Appendix A, morphisms that form aggregate/expand dual pairs may optionally implement `FrobeniusAlgebra`:

```scala
trait FrobeniusAlgebra[A] {
  def multiply(a1: A, a2: A): A    // mu: aggregate
  def comultiply(a: A): (A, A)     // delta: expand
  def unit: A                       // eta: identity element
  def counit(a: A): Unit           // epsilon: extract
}
```

This is Layer 2, not required for MVP. It enables algebraic pipeline optimization in future iterations.

## Consequences

### Positive

- Every morphism has a well-defined backward, enabling reconciliation and impact analysis
- Classification system gives users clear expectations about round-trip precision
- Metadata capture during forward execution avoids expensive recomputation for backward traversal
- Contravariant composition is validated at compile time
- Storage strategies provide flexibility for different performance/storage trade-offs
- The layered Frobenius approach allows incremental adoption

### Negative

- Adjoint metadata capture adds storage overhead (bounded by configurable budget)
- Every new morphism type requires defining its adjoint strategy
- Backward traversal through long chains of morphisms may be slow (sequential metadata lookups)
- The Lossy classification is a catch-all that provides limited backward utility

### Risks

- Storage overhead for reverse-join tables in high-cardinality aggregations (e.g., 1 billion source records aggregated to 1 million groups) could be significant. Mitigation: Roaring Bitmap compression, configurable storage budget, and lineage mode selection (RIC-LIN-01).
- Backward traversal correctness depends on metadata capture being complete and accurate during forward execution. Mitigation: the accounting invariant (REQ-ACC-01) verifies completeness.

## Alternatives Considered

1. **Dagger categories** — Require strict inverses (`f^dag = f^-1`), which is too strong for lossy operations. Rejected per INT-005 analysis.
2. **No backward** — Store only forward lineage. Severely limits reconciliation and impact analysis. Rejected as it fails REQ-ADJ-08 and REQ-ADJ-09.
3. **Recomputation-based backward** — Replay the forward computation with predicate pushdown instead of storing metadata. Saves storage but increases compute cost. Kept as an alternative lineage mode (RIC-LIN-01 Key-Derivable mode).
4. **Full Frobenius as baseline** — Requires defining comultiplication for every morphism, which is not always possible (e.g., hash functions). Rejected as overly restrictive; kept as optional Layer 2.

## References

- [ADR-001](ADR-001.md) — Sealed ADT Type System (AdjointClassification)
- [ADR-002](ADR-002.md) — Category Representation (Morphism.adjoint field)
- [ADR-003](ADR-003.md) — Either-Based Error Handling (backward returns Either)
- [ADR-005](ADR-005.md) — Grain Ordering System (adjoint respects grain)
- [ADR-009](ADR-009.md) — OpenLineage Integration (adjoint metadata in lineage events)
- REQ-ADJ-01 through REQ-ADJ-11 — Adjoint Morphisms requirements
- REQ-ACC-01 through REQ-ACC-05 — Record Accounting requirements
- Specification INT-005 — Adjoint Morphisms for Reverse Transformations
- Specification Appendix A — Frobenius Algebras
