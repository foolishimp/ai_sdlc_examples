# ADR-009: OpenLineage Integration

**Status**: Accepted
**Date**: 2026-02-23
**Implements**: REQ-INT-03, REQ-TRV-04, REQ-AI-02, REQ-TRV-05-A, REQ-COV-03, REQ-COV-08

## Context

The CDME specification requires full lineage traceability (REQ-INT-03): every target value must trace to specific source entities and epochs via the morphism path. This lineage must be:

- Exportable via OpenLineage API (REQ-TRV-04)
- Part of the Triangulation of Assurance (Intent -> Logic -> Proof) (REQ-AI-02)
- Bound to an immutable run manifest (REQ-TRV-05-A)
- Extended with fidelity certificates for cross-domain verification (REQ-COV-03, REQ-COV-08)
- Sufficient for regulatory compliance (BCBS 239, FRTB, EU AI Act)

OpenLineage is an open standard for data lineage events, providing a common format for lineage capture across data tools.

## Decision

Integrate with OpenLineage using the `openlineage-java` client library, extending the standard event model with CDME-specific custom facets.

### Event Lifecycle

Every CDME execution emits exactly three OpenLineage events:

| Event | When | Purpose |
|-------|------|---------|
| **START** | Execution begins | Declare inputs, outputs, and execution intent |
| **COMPLETE** | Execution succeeds, accounting invariant passes | Deliver full lineage, proofs, and ledger |
| **FAIL** | Execution fails or accounting invariant fails | Capture error context and partial results |

### Custom Facets

The standard OpenLineage event schema is extended with CDME-specific facets under the `cdme.*` namespace:

```json
{
  "eventType": "COMPLETE",
  "run": {
    "runId": "uuid",
    "facets": {
      "cdme.runManifest": {
        "configHash": "sha256:...",
        "codeHash": "sha256:...",
        "designHash": "sha256:...",
        "inputChecksums": { "source_a": "sha256:..." },
        "outputChecksums": { "target_b": "sha256:..." }
      },
      "cdme.accountingLedger": {
        "inputRecordCount": 1000000,
        "processedCount": 995000,
        "filteredCount": 4000,
        "erroredCount": 1000,
        "balanced": true
      },
      "cdme.typeUnification": {
        "morphismReports": [...]
      },
      "cdme.grainSafety": {
        "validations": [...]
      },
      "cdme.morphismTrace": {
        "targetAttributes": {
          "amount": ["source.trade.amount", "compute.fx_convert", "agg.sum"]
        }
      },
      "cdme.adjointMetadata": {
        "reverseJoinLocations": { "agg_1": "s3://bucket/lineage/rj_1.parquet" }
      },
      "cdme.fidelityCertificate": {
        "certificateId": "cert-001",
        "chainHash": "sha256:..."
      }
    }
  },
  "inputs": [...],
  "outputs": [...]
}
```

### Fidelity Certificate Chain (REQ-COV-08)

Fidelity certificates form a hash-linked chain:

```
cert_0 (genesis) -> cert_1 (hash of cert_0) -> cert_2 (hash of cert_1) -> ...
```

Each certificate contains:
- Source and target domain state hashes
- Contract version
- Invariant evaluation results (pass/fail per invariant)
- Materiality thresholds applied
- Timestamp and run ID

The chain is tamper-evident: modifying any certificate invalidates all subsequent chain hashes.

### Lineage Modes (RIC-LIN-01)

The lineage detail level in events varies by mode:

| Mode | Morphism Trace | Adjoint Metadata | Key Envelopes |
|------|---------------|------------------|---------------|
| Full | All morphisms, all records | Complete reverse-join tables | All checkpoints |
| Key-Derivable | All morphisms, key derivation info | Compressed envelopes | Strategic checkpoints |
| Sampled | All morphisms, sampled records | Sampled metadata | Sampled checkpoints |

Mode selection is per-job in the `ExecutionContext`.

### Telemetry Writer (REQ-TRV-04)

The Writer Monad pattern captures telemetry at every morphism execution:

```scala
trait TelemetryWriter {
  def recordMetrics(
      morphismId: MorphismId,
      rowCount: Long,
      latencyMs: Long,
      qualityStats: QualityStats
  ): Either[CdmeError, Unit]
}
```

Telemetry is accumulated during execution and serialized into the COMPLETE event's facets. Telemetry overhead target: < 5% of execution time (REQ-TRV-04).

## Consequences

### Positive

- OpenLineage is an open standard, ensuring interoperability with other data tools (Airflow, dbt, Spark built-in lineage)
- Custom facets extend rather than replace the standard, maintaining compatibility
- The hash-linked certificate chain provides tamper-evident regulatory evidence
- Lineage modes allow trading storage for performance
- The run manifest (REQ-TRV-05-A) enables exact reproduction of historical runs
- Telemetry capture at morphism level provides fine-grained observability

### Negative

- OpenLineage events can be large (megabytes) for complex pipelines with many morphisms
- Custom facets require consumers to understand CDME-specific schema
- The `openlineage-java` library adds a runtime dependency to cdme-lineage
- Fidelity certificate chain management (pruning, branching) adds operational complexity

### Risks

- OpenLineage standard evolution may introduce breaking changes to the event schema. Mitigation: pin openlineage-java version; wrap the client in a CDME adapter layer.
- Certificate chain integrity depends on consistent hashing. If the hashing algorithm changes, old chains become unverifiable. Mitigation: include hash algorithm identifier in each certificate.
- Telemetry overhead may exceed 5% for complex morphism chains with many columns. Mitigation: telemetry can be disabled per morphism if overhead is unacceptable.

## Alternatives Considered

1. **Custom lineage format (no OpenLineage)** — Maximum flexibility but loses interoperability with the data tooling ecosystem. Rejected.
2. **Apache Atlas** — Richer metadata model but heavyweight dependency (requires Kafka, HBase). Rejected for complexity.
3. **Lineage via Spark UI only** — Insufficient detail and not exportable for regulatory compliance. Rejected.
4. **W3C PROV** — Academic provenance standard, less adopted in data engineering. Rejected for ecosystem reasons.

## References

- [ADR-003](ADR-003.md) — Either-Based Error Handling (FAIL event content)
- [ADR-004](ADR-004.md) — Adjoint Morphism Design (adjoint metadata in events)
- [ADR-006](ADR-006.md) — Spark Integration Strategy (Spark-level lineage)
- [ADR-007](ADR-007.md) — Multi-Module sbt Structure (cdme-lineage module)
- [ADR-011](ADR-011.md) — Context and Epoch Management (epoch in events)
- REQ-INT-03 — Traceability
- REQ-TRV-04 — Operational Telemetry
- REQ-TRV-05-A — Immutable Run Hierarchy
- REQ-AI-02 — Triangulation of Assurance
- REQ-COV-03 — Fidelity Verification
- REQ-COV-08 — Fidelity Certificate Chain
- RIC-LIN-01 — Lineage Modes
